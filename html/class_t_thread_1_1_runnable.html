<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>opentoonz: TThread::Runnable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">opentoonz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>TThread</b></li><li class="navelem"><a class="el" href="class_t_thread_1_1_runnable.html">Runnable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_t_thread_1_1_runnable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TThread::Runnable Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="">tthread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TThread::Runnable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_t_thread_1_1_runnable.png" usemap="#TThread::Runnable_map" alt=""/>
  <map id="TThread::Runnable_map" name="TThread::Runnable_map">
<area href="class_t_smart_object.html" alt="TSmartObject" shape="rect" coords="242,0,474,24"/>
<area href="class_custom_style_manager_1_1_style_loader_task.html" alt="CustomStyleManager::StyleLoaderTask" shape="rect" coords="363,112,595,136"/>
<area href="class_data_reader.html" alt="DataReader" shape="rect" coords="363,168,595,192"/>
<area href="class_data_receiver.html" alt="DataReceiver" shape="rect" coords="363,224,595,248"/>
<area href="class_frame_count_task.html" alt="FrameCountTask" shape="rect" coords="363,280,595,304"/>
<area href="class_icon_renderer.html" alt="IconRenderer" shape="rect" coords="363,336,595,360"/>
<area href="class_image_processing.html" alt="ImageProcessing" shape="rect" coords="363,392,595,416"/>
<area href="class_record_task.html" alt="RecordTask" shape="rect" coords="363,448,595,472"/>
<area href="class_record_task.html" alt="RecordTask" shape="rect" coords="363,504,595,528"/>
<area href="class_render_task.html" alt="RenderTask" shape="rect" coords="363,560,595,584"/>
<area href="class_server_initializer.html" alt="ServerInitializer" shape="rect" coords="363,616,595,640"/>
<area href="class_swatch_viewer_1_1_content_render.html" alt="SwatchViewer::ContentRender" shape="rect" coords="363,672,595,696"/>
<area href="class_t_thread_1_1_executor_1_1_imp_1_1_worker.html" alt="TThread::Executor::Imp::Worker" shape="rect" coords="363,728,595,752"/>
<area href="class_task.html" alt="Task" shape="rect" coords="363,784,595,808"/>
<area href="class_task_runner.html" alt="TaskRunner" shape="rect" coords="363,840,595,864"/>
<area href="class_task_starter.html" alt="TaskStarter" shape="rect" coords="363,896,595,920"/>
<area href="class_vectorization_swatch_task.html" alt="VectorizationSwatchTask" shape="rect" coords="363,952,595,976"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-slots" name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr class="memitem:a0857d4a039557f2853a12203ea854f01"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="separator:a0857d4a039557f2853a12203ea854f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08796496a74b40c4e1940e386f7926f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#ae08796496a74b40c4e1940e386f7926f">onFinished</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="memdesc:ae08796496a74b40c4e1940e386f7926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The analogous of <a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted()</a> for the <a class="el" href="class_t_thread_1_1_runnable.html#a77da4aa600bdb892b55312efcd6e3a21">finished()</a> signal.  <a href="class_t_thread_1_1_runnable.html#ae08796496a74b40c4e1940e386f7926f">More...</a><br /></td></tr>
<tr class="separator:ae08796496a74b40c4e1940e386f7926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6a991a0e5d2c1fe1885f43928c50ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a1a6a991a0e5d2c1fe1885f43928c50ed">onException</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="memdesc:a1a6a991a0e5d2c1fe1885f43928c50ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The analogous of <a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted()</a> for the <a class="el" href="class_t_thread_1_1_runnable.html#a9dd092bdcdc53e1ed45851562417e135">exception()</a> signal.  <a href="class_t_thread_1_1_runnable.html#a1a6a991a0e5d2c1fe1885f43928c50ed">More...</a><br /></td></tr>
<tr class="separator:a1a6a991a0e5d2c1fe1885f43928c50ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec8792febe8d01c9fddf868a4605f65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#adec8792febe8d01c9fddf868a4605f65">onCanceled</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="memdesc:adec8792febe8d01c9fddf868a4605f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The analogous of <a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted()</a> for the <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled()</a> signal.  <a href="class_t_thread_1_1_runnable.html#adec8792febe8d01c9fddf868a4605f65">More...</a><br /></td></tr>
<tr class="separator:adec8792febe8d01c9fddf868a4605f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734635ad9bf10ec12afcc6f305af8c55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a734635ad9bf10ec12afcc6f305af8c55">onTerminated</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="memdesc:a734635ad9bf10ec12afcc6f305af8c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The analogous of <a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted()</a> for the <a class="el" href="class_t_thread_1_1_runnable.html#afda69c2f2eb6df8d30d7668a4cdd60da">terminated()</a> signal.  <a href="class_t_thread_1_1_runnable.html#a734635ad9bf10ec12afcc6f305af8c55">More...</a><br /></td></tr>
<tr class="separator:a734635ad9bf10ec12afcc6f305af8c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="signals" name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a4603628ddbc41e9e73e027e8f817bff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a4603628ddbc41e9e73e027e8f817bff1">started</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="separator:a4603628ddbc41e9e73e027e8f817bff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77da4aa600bdb892b55312efcd6e3a21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a77da4aa600bdb892b55312efcd6e3a21">finished</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="separator:a77da4aa600bdb892b55312efcd6e3a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd092bdcdc53e1ed45851562417e135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a9dd092bdcdc53e1ed45851562417e135">exception</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="separator:a9dd092bdcdc53e1ed45851562417e135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a003e7e55636146017bd05df73531a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="separator:a87a003e7e55636146017bd05df73531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda69c2f2eb6df8d30d7668a4cdd60da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#afda69c2f2eb6df8d30d7668a4cdd60da">terminated</a> (<a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a> sender)</td></tr>
<tr class="separator:afda69c2f2eb6df8d30d7668a4cdd60da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad3b8ee5e7b375bd169f7382fa26b00ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef">run</a> ()=0</td></tr>
<tr class="memdesc:ad3b8ee5e7b375bd169f7382fa26b00ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The central code of the task that is executed by a worker thread.  <a href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef">More...</a><br /></td></tr>
<tr class="separator:ad3b8ee5e7b375bd169f7382fa26b00ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c08dc36ed7b4c9e35809ea696c91e95"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a9c08dc36ed7b4c9e35809ea696c91e95">taskLoad</a> ()</td></tr>
<tr class="separator:a9c08dc36ed7b4c9e35809ea696c91e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e52533850da5433f3075d3d032182c1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a7e52533850da5433f3075d3d032182c1">schedulingPriority</a> ()</td></tr>
<tr class="separator:a7e52533850da5433f3075d3d032182c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7266725bb29e0ba78a4d3ddb728a5aac"><td class="memItemLeft" align="right" valign="top">virtual QThread::Priority&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a7266725bb29e0ba78a4d3ddb728a5aac">runningPriority</a> ()</td></tr>
<tr class="separator:a7266725bb29e0ba78a4d3ddb728a5aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_t_smart_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_t_smart_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_t_smart_object.html">TSmartObject</a></td></tr>
<tr class="memitem:ab9a1e31b7e2b8c9b141fe9ce7e8cf489 inherit pub_methods_class_t_smart_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_smart_object.html#ab9a1e31b7e2b8c9b141fe9ce7e8cf489">TSmartObject</a> (ClassCode classCode)</td></tr>
<tr class="separator:ab9a1e31b7e2b8c9b141fe9ce7e8cf489 inherit pub_methods_class_t_smart_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a76a715c1785eb545fa3ef2f6e06928 inherit pub_methods_class_t_smart_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_smart_object.html#a4a76a715c1785eb545fa3ef2f6e06928">addRef</a> ()</td></tr>
<tr class="separator:a4a76a715c1785eb545fa3ef2f6e06928 inherit pub_methods_class_t_smart_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99750961461978d73f55a4a54e6f874e inherit pub_methods_class_t_smart_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_smart_object.html#a99750961461978d73f55a4a54e6f874e">release</a> ()</td></tr>
<tr class="separator:a99750961461978d73f55a4a54e6f874e inherit pub_methods_class_t_smart_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1dab21fd93f07fdf6c86661d738a5 inherit pub_methods_class_t_smart_object"><td class="memItemLeft" align="right" valign="top">TINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_smart_object.html#ac1f1dab21fd93f07fdf6c86661d738a5">getRefCount</a> () const</td></tr>
<tr class="separator:ac1f1dab21fd93f07fdf6c86661d738a5 inherit pub_methods_class_t_smart_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a763b2f90bc53f92d680a635fe28e858e"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a763b2f90bc53f92d680a635fe28e858e">Executor</a></td></tr>
<tr class="separator:a763b2f90bc53f92d680a635fe28e858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af022abc71323b07be5460515acab8737"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#af022abc71323b07be5460515acab8737">ExecutorImp</a></td></tr>
<tr class="separator:af022abc71323b07be5460515acab8737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de4a9533dff2ecc0919852d4c05a67b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_runnable.html#a9de4a9533dff2ecc0919852d4c05a67b">Worker</a></td></tr>
<tr class="separator:a9de4a9533dff2ecc0919852d4c05a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_t_smart_object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_t_smart_object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_t_smart_object.html">TSmartObject</a></td></tr>
<tr class="memitem:a3bc37f54976a445f30c99753a478feae inherit pub_types_class_t_smart_object"><td class="memItemLeft" align="right" valign="top">typedef short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_smart_object.html#a3bc37f54976a445f30c99753a478feae">ClassCode</a></td></tr>
<tr class="separator:a3bc37f54976a445f30c99753a478feae inherit pub_types_class_t_smart_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_t_smart_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_t_smart_object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_t_smart_object.html">TSmartObject</a></td></tr>
<tr class="memitem:a41e6552e87694c0edba6acc7e57b5752 inherit pub_static_methods_class_t_smart_object"><td class="memItemLeft" align="right" valign="top">static TINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_smart_object.html#a41e6552e87694c0edba6acc7e57b5752">getInstanceCount</a> (ClassCode code)</td></tr>
<tr class="separator:a41e6552e87694c0edba6acc7e57b5752 inherit pub_static_methods_class_t_smart_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="class_t_thread_1_1_runnable.html">Runnable</a> class is the abstract model for user-defined tasks which can be scheduled for execution into separate application threads.</p>
<p >A user must first implement the <a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef" title="The central code of the task that is executed by a worker thread.">run()</a> method to provide a task with the very execution code. <a class="el" href="class_t_thread_1_1_worker.html">Worker</a> threads created internally by the task manager will take ownership of the task and make it <a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef" title="The central code of the task that is executed by a worker thread.">run()</a> at the most appropriate time, depending on the task load, insertion time and its scheduling priority. <br  />
 <br  />
 The scheduling priority of a task can be set by reimplementing the <b><a class="el" href="class_t_thread_1_1_runnable.html#a7e52533850da5433f3075d3d032182c1">schedulingPriority()</a></b> method. Tasks whose scheduling priority is higher are always started before compared to the others added by the same executor. <br  />
 <br  />
 The hosting thread's running priority may also be set reimplementing the <a class="el" href="class_t_thread_1_1_runnable.html#a7266725bb29e0ba78a4d3ddb728a5aac">runningPriority()</a> method; see QThread class documentation in Qt manual. <br  />
 <br  />
 A task's load is an important property that should be reimplemented in all resource-consuming tasks. It enables the user to declare the approximate CPU load produced by a task, allowing the task manager to effectively calculate the most appropriate moment to run it.</p>
<dl class="section warning"><dt>Warning</dt><dd><br  />
 All built-in signals about the <a class="el" href="class_t_thread_1_1_runnable.html">Runnable</a> class are emitted in a mutex-protected environment in order to make sure that signal emission is consistent with the task status - in other words, so that <em>queued</em> controller-emitted <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled()</a> and <a class="el" href="class_t_thread_1_1_runnable.html#afda69c2f2eb6df8d30d7668a4cdd60da">terminated()</a> signals are not delivered <em>before</em> <a class="el" href="class_t_thread_1_1_runnable.html#a4603628ddbc41e9e73e027e8f817bff1">started()</a> or <em>after</em> <a class="el" href="class_t_thread_1_1_runnable.html#a77da4aa600bdb892b55312efcd6e3a21">finished()</a> and <a class="el" href="class_t_thread_1_1_runnable.html#a9dd092bdcdc53e1ed45851562417e135">exception()</a> worker-emitted signals.</dd>
<dd>
Thus, setting up blocking connections or blocking direct slots is <b>not</b> <b>supported</b> and will typically result in deadlocks; furthermore, the same also applies to slot calls to the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> API, which would have the aforementioned mutex to be locked again.</dd>
<dd>
In case the above blocking strategies are mandatory, the user should add custom signals to be emitted inside the mutex-free <a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef" title="The central code of the task that is executed by a worker thread.">run()</a> block, just before or after the actual code to be executed, like this:</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyTask::run()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    emit myStarted(<span class="keyword">this</span>);</div>
<div class="line">    theRunCode();</div>
<div class="line">    emit myFinished(<span class="keyword">this</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    emit myException(<span class="keyword">this</span>);</div>
<div class="line">    <span class="keywordflow">throw</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  ..</div>
<div class="line">  MyTask* myTask = <span class="keyword">new</span> MyTask;</div>
<div class="line">  connect(myTask, SIGNAL(myStarted(<a class="code hl_class" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>)), myTask,</div>
<div class="line">SLOT(<a class="code hl_slot" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted</a>(<a class="code hl_class" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>)),</div>
<div class="line">    Qt::BlockingQueuedConnection)   <span class="comment">//theRunCode() waits for onStarted() to</span></div>
<div class="line">complete</div>
<div class="line">  ..</div>
<div class="ttc" id="aclass_t_smart_pointer_t_html"><div class="ttname"><a href="class_t_smart_pointer_t.html">TSmartPointerT&lt; Runnable &gt;</a></div></div>
<div class="ttc" id="aclass_t_thread_1_1_runnable_html_a0857d4a039557f2853a12203ea854f01"><div class="ttname"><a href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">TThread::Runnable::onStarted</a></div><div class="ttdeci">virtual void onStarted(TThread::RunnableP sender)</div><div class="ttdef"><b>Definition:</b> tthread.cpp:487</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_t_thread_1_1_executor.html">Executor</a> class. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a19af0a2e2b8f986c51196b9c4b2340fb" name="a19af0a2e2b8f986c51196b9c4b2340fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19af0a2e2b8f986c51196b9c4b2340fb">&#9670;&nbsp;</a></span>Runnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Runnable::Runnable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  335</span>: <a class="code hl_class" href="class_t_smart_object.html">TSmartObject</a>(m_classCode), m_id(0) {}</div>
<div class="ttc" id="aclass_t_smart_object_html"><div class="ttname"><a href="class_t_smart_object.html">TSmartObject</a></div><div class="ttdef"><b>Definition:</b> tsmartpointer.h:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bf7483afb8d40ec8dbec57efb64f0c2" name="a3bf7483afb8d40ec8dbec57efb64f0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf7483afb8d40ec8dbec57efb64f0c2">&#9670;&nbsp;</a></span>~Runnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Runnable::~Runnable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  339</span>                    {</div>
<div class="line"><span class="lineno">  340</span>  <span class="keywordflow">if</span> (m_id) m_id-&gt;release();  <span class="comment">// see Executor::addTask()</span></div>
<div class="line"><span class="lineno">  341</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a87a003e7e55636146017bd05df73531a" name="a87a003e7e55636146017bd05df73531a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a003e7e55636146017bd05df73531a">&#9670;&nbsp;</a></span>canceled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::canceled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The <b>canceled</b> signal is emitted from the controller thread whenever a task which is currently under the task manager's control is canceled by the user (the signal is emitted from the thread invoking the cancel). Observe that tasks under execution are not stopped by the task manager when they are canceled, but the signal is emitted anyway - helping the user to stop the actual execution of the <a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef" title="The central code of the task that is executed by a worker thread.">run()</a> code in advance.</p>
<dl class="section see"><dt>See also</dt><dd><b><a class="el" href="class_t_thread_1_1_executor.html#a6aabf03f90569a0fceb86f5a3d054c9b">Executor::removeTask</a></b> and <b><a class="el" href="class_t_thread_1_1_executor.html#a3ebba69410a233ff1e5774d7e4d1246f">Executor::cancelAll</a></b> methods. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#l00860">TThread::Executor::cancelAll()</a>, <a class="el" href="#l00831">TThread::Executor::removeTask()</a>, and <a class="el" href="#l00725">TThread::Executor::shutdown()</a>.</p>

</div>
</div>
<a id="a9dd092bdcdc53e1ed45851562417e135" name="a9dd092bdcdc53e1ed45851562417e135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd092bdcdc53e1ed45851562417e135">&#9670;&nbsp;</a></span>exception</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::exception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The <b>exception</b> signal is emitted from working threads whenever an untrapped exception is found within the <a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef" title="The central code of the task that is executed by a worker thread.">run()</a> method.</p>
<dl class="section see"><dt>See also</dt><dd><b><a class="el" href="class_t_thread_1_1_runnable.html#a4603628ddbc41e9e73e027e8f817bff1">started</a></b> and <b><a class="el" href="class_t_thread_1_1_runnable.html#a77da4aa600bdb892b55312efcd6e3a21">finished</a></b> signals. </dd></dl>

</div>
</div>
<a id="a77da4aa600bdb892b55312efcd6e3a21" name="a77da4aa600bdb892b55312efcd6e3a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77da4aa600bdb892b55312efcd6e3a21">&#9670;&nbsp;</a></span>finished</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::finished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The <b>finished</b> signal is emitted from working threads once the <a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef" title="The central code of the task that is executed by a worker thread.">run()</a> code is returned without unmanaged exceptions.</p>
<dl class="section see"><dt>See also</dt><dd><b><a class="el" href="class_t_thread_1_1_runnable.html#a4603628ddbc41e9e73e027e8f817bff1">started</a></b> and <b><a class="el" href="class_t_thread_1_1_runnable.html#a9dd092bdcdc53e1ed45851562417e135">exception</a></b> signals. </dd></dl>

</div>
</div>
<a id="adec8792febe8d01c9fddf868a4605f65" name="adec8792febe8d01c9fddf868a4605f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec8792febe8d01c9fddf868a4605f65">&#9670;&nbsp;</a></span>onCanceled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::onCanceled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The analogous of <a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted()</a> for the <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled()</a> signal. </p>

<p>Reimplemented in <a class="el" href="class_swatch_viewer_1_1_content_render.html#a0aa812ce92b073e6215ef7ea1d6ebf88">SwatchViewer::ContentRender</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  502</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a6a991a0e5d2c1fe1885f43928c50ed" name="a1a6a991a0e5d2c1fe1885f43928c50ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6a991a0e5d2c1fe1885f43928c50ed">&#9670;&nbsp;</a></span>onException</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::onException </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The analogous of <a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted()</a> for the <a class="el" href="class_t_thread_1_1_runnable.html#a9dd092bdcdc53e1ed45851562417e135">exception()</a> signal. </p>
<div class="fragment"><div class="line"><span class="lineno">  497</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae08796496a74b40c4e1940e386f7926f" name="ae08796496a74b40c4e1940e386f7926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08796496a74b40c4e1940e386f7926f">&#9670;&nbsp;</a></span>onFinished</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::onFinished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The analogous of <a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted()</a> for the <a class="el" href="class_t_thread_1_1_runnable.html#a77da4aa600bdb892b55312efcd6e3a21">finished()</a> signal. </p>

<p>Reimplemented in <a class="el" href="class_custom_style_manager_1_1_style_loader_task.html#a5873b829af2c6fef514221fe0789768a">CustomStyleManager::StyleLoaderTask</a>, <a class="el" href="class_image_processing.html#ab5b2ae15d92b76aea9512b684e872752">ImageProcessing</a>, <a class="el" href="class_swatch_viewer_1_1_content_render.html#a4cc5e5b654a620e5a3079653642366d8">SwatchViewer::ContentRender</a>, <a class="el" href="class_vectorization_swatch_task.html#aa4d5f1bc292d9970aa26ebdbb0d62256">VectorizationSwatchTask</a>, and <a class="el" href="class_render_task.html#a58ffdff3acd6939971633419f990de20">RenderTask</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  492</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0857d4a039557f2853a12203ea854f01" name="a0857d4a039557f2853a12203ea854f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0857d4a039557f2853a12203ea854f01">&#9670;&nbsp;</a></span>onStarted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::onStarted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convenience slot for the <a class="el" href="class_t_thread_1_1_runnable.html#a4603628ddbc41e9e73e027e8f817bff1">started()</a> signal - so it's not necessary to declare the task in a header file for moc'ing each time. You must both reimplement <b>and</b> connect it to the <a class="el" href="class_t_thread_1_1_runnable.html#a4603628ddbc41e9e73e027e8f817bff1">started()</a> signal to make it work. </p>

<p>Reimplemented in <a class="el" href="class_swatch_viewer_1_1_content_render.html#abc7c080853b166ff7606020946b4c4f3">SwatchViewer::ContentRender</a>, and <a class="el" href="class_vectorization_swatch_task.html#a0d12be0521240b78940f782f279a3ea5">VectorizationSwatchTask</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  487</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a734635ad9bf10ec12afcc6f305af8c55" name="a734635ad9bf10ec12afcc6f305af8c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734635ad9bf10ec12afcc6f305af8c55">&#9670;&nbsp;</a></span>onTerminated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::onTerminated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The analogous of <a class="el" href="class_t_thread_1_1_runnable.html#a0857d4a039557f2853a12203ea854f01">onStarted()</a> for the <a class="el" href="class_t_thread_1_1_runnable.html#afda69c2f2eb6df8d30d7668a4cdd60da">terminated()</a> signal. </p>
<div class="fragment"><div class="line"><span class="lineno">  507</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3b8ee5e7b375bd169f7382fa26b00ef" name="ad3b8ee5e7b375bd169f7382fa26b00ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b8ee5e7b375bd169f7382fa26b00ef">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TThread::Runnable::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The central code of the task that is executed by a worker thread. </p>

<p>Implemented in <a class="el" href="class_record_task.html#a50595a867aa01463105b6a600383ea09">RecordTask</a>, <a class="el" href="class_image_processing.html#ab36d5885f31dd7c2a3bb61502a70e66b">ImageProcessing</a>, <a class="el" href="class_t_thread_1_1_executor_1_1_imp_1_1_worker.html#ae9adbb9f01d151d8f7fd886c9418dffd">TThread::Executor::Imp::Worker</a>, <a class="el" href="class_render_task.html#aa29790caf493428270230adef46f46bc">RenderTask</a>, <a class="el" href="class_record_task.html#ae4c2034b89607059c7e7dfc3fcca87a3">RecordTask</a>, <a class="el" href="class_swatch_viewer_1_1_content_render.html#a6f26a0168b2acfcc47889fd7a52c1e09">SwatchViewer::ContentRender</a>, <a class="el" href="class_task_runner.html#a2b9df073863b93e0ee35a0c1949a8f6e">TaskRunner</a>, <a class="el" href="class_frame_count_task.html#a6f14324f0ed74122a1eb1dfb9b754692">FrameCountTask</a>, <a class="el" href="class_vectorization_swatch_task.html#a5860ad48ba39f5e71b0486b65bd44246">VectorizationSwatchTask</a>, <a class="el" href="class_data_reader.html#a5e0041ec8b2df52c678ffe0b7f2cd2cd">DataReader</a>, <a class="el" href="class_data_receiver.html#a29df6f1aacc94468f9308955b1e20b64">DataReceiver</a>, <a class="el" href="class_server_initializer.html#a14fb2d991f2d45661f6ca5da2a30c5e8">ServerInitializer</a>, <a class="el" href="class_task_starter.html#aaeb45c827fa43859ed1c6885cac6d62f">TaskStarter</a>, <a class="el" href="class_task.html#aa2b4b735177b3ad885a9f6b590300b3f">Task</a>, <a class="el" href="class_custom_style_manager_1_1_style_loader_task.html#acb5dbd32cf6c8716d982fa273a78271b">CustomStyleManager::StyleLoaderTask</a>, <a class="el" href="class_vector_image_icon_renderer.html#ac3a9316bed3de457269493221010214a">VectorImageIconRenderer</a>, <a class="el" href="class_spline_icon_renderer.html#a053c9e5d86ba8bb7b0430ad1d0879d69">SplineIconRenderer</a>, <a class="el" href="class_raster_image_icon_renderer.html#a61fa8cec2e0910c1f1300dbe02e58b47">RasterImageIconRenderer</a>, <a class="el" href="class_toonz_image_icon_renderer.html#a23c50ffd61db13c673911d35fdec7b60">ToonzImageIconRenderer</a>, <a class="el" href="class_mesh_image_icon_renderer.html#abbeebd3c695180ccbfd0c9d04f4952b2">MeshImageIconRenderer</a>, <a class="el" href="class_xsheet_icon_renderer.html#a54451126f96b8fc1d2002def066bc142">XsheetIconRenderer</a>, <a class="el" href="class_file_icon_renderer.html#acb43d3b6991244c29c9aef674abc46a7">FileIconRenderer</a>, <a class="el" href="class_scene_icon_renderer.html#a1ccaa355854cb3665ffa679f3e2f8375">SceneIconRenderer</a>, and <a class="el" href="class_icon_renderer.html#a0861b8f15a0a79a11c5675807537c230">IconRenderer</a>.</p>

</div>
</div>
<a id="a7266725bb29e0ba78a4d3ddb728a5aac" name="a7266725bb29e0ba78a4d3ddb728a5aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7266725bb29e0ba78a4d3ddb728a5aac">&#9670;&nbsp;</a></span>runningPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QThread::Priority Runnable::runningPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the QThread::Priority used by worker threads when they adopt the task. The default value returned is QThread::Normal. </p>

<p>Reimplemented in <a class="el" href="class_frame_count_task.html#acb732c7156e6baaa33f61f10544cdfb0">FrameCountTask</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  400</span>                                          {</div>
<div class="line"><span class="lineno">  401</span>  <span class="keywordflow">return</span> QThread::NormalPriority;</div>
<div class="line"><span class="lineno">  402</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e52533850da5433f3075d3d032182c1" name="a7e52533850da5433f3075d3d032182c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e52533850da5433f3075d3d032182c1">&#9670;&nbsp;</a></span>schedulingPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Runnable::schedulingPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the priority value used to schedule a task for execution. Tasks with higher priority start before tasks with lower priority. The default value returned is 5 (halfway from 0 to 10) - but any value other than (std::numeric_limits&lt;int&gt;::max)() is acceptable. </p>
<div class="fragment"><div class="line"><span class="lineno">  394</span>{ <span class="keywordflow">return</span> 5; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="#l00804">TThread::Executor::addTask()</a>.</p>

</div>
</div>
<a id="a4603628ddbc41e9e73e027e8f817bff1" name="a4603628ddbc41e9e73e027e8f817bff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4603628ddbc41e9e73e027e8f817bff1">&#9670;&nbsp;</a></span>started</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::started </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This signal is emitted from working threads just before the <a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef" title="The central code of the task that is executed by a worker thread.">run()</a> code is executed. Observe that the passed smart pointer ensures the survival of the emitting task for the time required by connected slots execution.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="class_t_thread_1_1_runnable.html#a4603628ddbc41e9e73e027e8f817bff1">started()</a>, <a class="el" href="class_t_thread_1_1_runnable.html#a77da4aa600bdb892b55312efcd6e3a21">finished()</a> and <a class="el" href="class_t_thread_1_1_runnable.html#a9dd092bdcdc53e1ed45851562417e135">exception()</a> signals are emitted in a mutex-protected environment in order to provide the correct sequence of emissions (i.e. so that <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled()</a> and <a class="el" href="class_t_thread_1_1_runnable.html#afda69c2f2eb6df8d30d7668a4cdd60da">terminated()</a> controller-emitted signals are either delivered after <a class="el" href="class_t_thread_1_1_runnable.html#a4603628ddbc41e9e73e027e8f817bff1">started()</a> and before <a class="el" href="class_t_thread_1_1_runnable.html#a77da4aa600bdb892b55312efcd6e3a21">finished()</a> or <a class="el" href="class_t_thread_1_1_runnable.html#a9dd092bdcdc53e1ed45851562417e135">exception()</a>, or <em>instead</em> of them). </dd>
<dd>
Thus, setting up blocking connections or <em>direct</em> slots that contain a blocking instruction or even calls to the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> API (which would definitely try to relock the aforementioned mutex) is dangerous and could result in an application freeze. </dd>
<dd>
In case it's necessary to use blocking features, they should be enforced through custom signals to be invoked manually in the <a class="el" href="class_t_thread_1_1_runnable.html#ad3b8ee5e7b375bd169f7382fa26b00ef" title="The central code of the task that is executed by a worker thread.">run()</a> method, outside the mutex.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><b><a class="el" href="class_t_thread_1_1_runnable.html#a77da4aa600bdb892b55312efcd6e3a21">finished</a></b> and <b><a class="el" href="class_t_thread_1_1_runnable.html#a9dd092bdcdc53e1ed45851562417e135">exception</a></b> signals. </dd></dl>

</div>
</div>
<a id="a9c08dc36ed7b4c9e35809ea696c91e95" name="a9c08dc36ed7b4c9e35809ea696c91e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c08dc36ed7b4c9e35809ea696c91e95">&#9670;&nbsp;</a></span>taskLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Runnable::taskLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the predicted CPU load generated by the task, expressed in percentage of core usage (that is, 100 is intended to fully occupy one processing core). Appropriate task load calibration is an important step to take when implementing a new task; for this purpose, remember some rules to follow: </p><ul>
<li>
In every moment, the task manager ensures that the overall sum of the active task's load does not exceed the number of machine's processing cores multiplied by 100. This condition is <em>blocking</em> with respect to the execution of any other task - meaning that when a task is about to be executed the task manager <em>waits</em> until enough CPU resources are available to make it run. In particular, observe that a task's load <b>never</b> has to exceed the total CPU resources - doing so would surely result in a block of your application. The number of available cores can be accessed via the <b>TSystem::getProcessorCount()</b> or <b>QThread::idealThreadCount()</b>. </li>
<li>
The task load is considered constant for the duration of the task. Changing its value does not affect the task manager in any way once the task has been started. </li>
<li>
The default task load is 0, representing a very light task. If the task load is 0 the condition at point 1 always succeeds - so the task is always executed when encountered. Observe that a long succession of 0 task loads leads to the creation of a proportional number of threads simultaneously running to dispatch it; if this is a problem, consider the use of <b><a class="el" href="class_t_thread_1_1_executor.html#a85231531a2fa273db401f090c9aba4ea">Executor::setMaxActiveTasks()</a></b> to make only a certain number of tasks being executed at the same time. </li>
</ul>

<p>Reimplemented in <a class="el" href="class_render_task.html#a1e59b3deba3c988b62e78e81bda1172f">RenderTask</a>, <a class="el" href="class_swatch_viewer_1_1_content_render.html#ab94f7f8cb69319c0363cf4ad43cccfc7">SwatchViewer::ContentRender</a>, and <a class="el" href="class_task_runner.html#a13742cc8e87e4fa14ff9c531508e1978">TaskRunner</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  386</span>{ <span class="keywordflow">return</span> 0; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afda69c2f2eb6df8d30d7668a4cdd60da" name="afda69c2f2eb6df8d30d7668a4cdd60da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda69c2f2eb6df8d30d7668a4cdd60da">&#9670;&nbsp;</a></span>terminated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Runnable::terminated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">TThread::RunnableP</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The <b>terminated</b> signal is emitted from the controller thread when the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> components are shutting down inside a call to <a class="el" href="class_t_thread_1_1_executor.html#ad11a0430a6be6601a2e5aa34a10c3b60">Executor::shutdown()</a>. Implementing a slot connected to this signal helps the user in controlling the flow of an Executor-multithreaded application when it is shutting down - for example, it can be imposed that the application must wait for the task to be finished, print logs or similar. This signal is always preceded by a <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled()</a> signal, informing all active tasks that they should begin quitting on their own in a 'soft' way before brute termination may occur.</p>
<dl class="section see"><dt>See also</dt><dd><b><a class="el" href="class_t_thread_1_1_executor.html#ad11a0430a6be6601a2e5aa34a10c3b60">Executor::shutdown</a></b> static method and <b><a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">Runnable::canceled</a></b> signal. </dd></dl>

<p class="reference">Referenced by <a class="el" href="#l00725">TThread::Executor::shutdown()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a763b2f90bc53f92d680a635fe28e858e" name="a763b2f90bc53f92d680a635fe28e858e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763b2f90bc53f92d680a635fe28e858e">&#9670;&nbsp;</a></span>Executor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_t_thread_1_1_executor.html">Executor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af022abc71323b07be5460515acab8737" name="af022abc71323b07be5460515acab8737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af022abc71323b07be5460515acab8737">&#9670;&nbsp;</a></span>ExecutorImp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_t_thread_1_1_executor_imp.html">ExecutorImp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9de4a9533dff2ecc0919852d4c05a67b" name="a9de4a9533dff2ecc0919852d4c05a67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de4a9533dff2ecc0919852d4c05a67b">&#9670;&nbsp;</a></span>Worker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_t_thread_1_1_worker.html">Worker</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>E:/opentoonz/toonz/sources/include/<a class="el" href="">tthread.h</a></li>
<li>E:/opentoonz/toonz/sources/common/tcore/<a class="el" href="">tthread.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
