<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>opentoonz: TThread::Executor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">opentoonz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>TThread</b></li><li class="navelem"><a class="el" href="class_t_thread_1_1_executor.html">Executor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_t_thread_1_1_executor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TThread::Executor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="">tthread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor_1_1_imp.html">Imp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af31c8db8ac72df4c342e7769e95e2135"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#af31c8db8ac72df4c342e7769e95e2135">addTask</a> (<a class="el" href="class_t_smart_pointer_t.html">RunnableP</a> task)</td></tr>
<tr class="separator:af31c8db8ac72df4c342e7769e95e2135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aabf03f90569a0fceb86f5a3d054c9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#a6aabf03f90569a0fceb86f5a3d054c9b">removeTask</a> (<a class="el" href="class_t_smart_pointer_t.html">RunnableP</a> task)</td></tr>
<tr class="separator:a6aabf03f90569a0fceb86f5a3d054c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebba69410a233ff1e5774d7e4d1246f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#a3ebba69410a233ff1e5774d7e4d1246f">cancelAll</a> ()</td></tr>
<tr class="separator:a3ebba69410a233ff1e5774d7e4d1246f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85231531a2fa273db401f090c9aba4ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#a85231531a2fa273db401f090c9aba4ea">setMaxActiveTasks</a> (int count)</td></tr>
<tr class="separator:a85231531a2fa273db401f090c9aba4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260fbe2faa1ee57f2042a03aaf30ec1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#a260fbe2faa1ee57f2042a03aaf30ec1b">setMaxActiveLoad</a> (int load)</td></tr>
<tr class="separator:a260fbe2faa1ee57f2042a03aaf30ec1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966129289d00b7539df5f1b85c41a369"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#a966129289d00b7539df5f1b85c41a369">maxActiveTasks</a> () const</td></tr>
<tr class="separator:a966129289d00b7539df5f1b85c41a369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114387a08ab8e53bdbbc30e2f53a336b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#a114387a08ab8e53bdbbc30e2f53a336b">maxActiveLoad</a> () const</td></tr>
<tr class="separator:a114387a08ab8e53bdbbc30e2f53a336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c4c637864647ce22be391919049d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#a02c4c637864647ce22be391919049d3a">setDedicatedThreads</a> (bool dedicated, bool persistent=true)</td></tr>
<tr class="memdesc:a02c4c637864647ce22be391919049d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the use of dedicated threads for the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a>'s task group.  <a href="class_t_thread_1_1_executor.html#a02c4c637864647ce22be391919049d3a">More...</a><br /></td></tr>
<tr class="separator:a02c4c637864647ce22be391919049d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab4f19cebb2e9ffa04ef22aec42d402b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#ab4f19cebb2e9ffa04ef22aec42d402b7">init</a> ()</td></tr>
<tr class="separator:ab4f19cebb2e9ffa04ef22aec42d402b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11a0430a6be6601a2e5aa34a10c3b60"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#ad11a0430a6be6601a2e5aa34a10c3b60">shutdown</a> ()</td></tr>
<tr class="separator:ad11a0430a6be6601a2e5aa34a10c3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af022abc71323b07be5460515acab8737"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_thread_1_1_executor.html#af022abc71323b07be5460515acab8737">ExecutorImp</a></td></tr>
<tr class="separator:af022abc71323b07be5460515acab8737"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="class_t_thread_1_1_executor.html">Executor</a> class provides an effective way for planning the execution of user-defined tasks that require separate working threads.</p>
<p >When an application needs to perform a resource-consuming task, it is often a good idea to dedicate a separate thread for it, especially in GUI applications; however, doing so eventually raises the problem of managing such intensive tasks in a way that constantly ensures the correct use of the machine resources - so that in any given time the CPU usage is maximal, but not overloaded. Additional requests by the user may arise, including preferenced ordering among tasks, the necessity of salvaging some CPU resources or threads for incoming tasks, and so on. <br  />
 <br  />
 The TThread namespace API contains two main classes, <b><a class="el" href="class_t_thread_1_1_runnable.html">Runnable</a></b> and <b><a class="el" href="class_t_thread_1_1_executor.html">Executor</a></b>, which provide a way for implementing consistent threading strategies. <br  />
 <br  />
 In order to use the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> class it is first necessary to install the thread manager into application code by calling the static method <a class="el" href="class_t_thread_1_1_executor.html#ab4f19cebb2e9ffa04ef22aec42d402b7">init()</a> appropriately. <br  />
 <br  />
 Executors are then used to submit - or eventually remove - tasks for execution into a separate working thread, by means of the <b><a class="el" href="class_t_thread_1_1_executor.html#af31c8db8ac72df4c342e7769e95e2135">addTask()</a></b>, <b><a class="el" href="class_t_thread_1_1_executor.html#a6aabf03f90569a0fceb86f5a3d054c9b">removeTask()</a></b> and <b><a class="el" href="class_t_thread_1_1_executor.html#a3ebba69410a233ff1e5774d7e4d1246f">cancelAll()</a></b> methods. Each <a class="el" href="class_t_thread_1_1_executor.html">Executor</a>'s visibility is always limited to the tasks that it submits - so calling <a class="el" href="class_t_thread_1_1_executor.html#a6aabf03f90569a0fceb86f5a3d054c9b">removeTask()</a> or <a class="el" href="class_t_thread_1_1_executor.html#a3ebba69410a233ff1e5774d7e4d1246f">cancelAll()</a> only affects the tasks previously added by that same <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> - which easily reflects the idea of an <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> representing a group of tasks. <br  />
 <br  />
 Basic control over the execution strategy for the group of tasks submitted by an <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> can be acquired using the <a class="el" href="class_t_thread_1_1_executor.html#a85231531a2fa273db401f090c9aba4ea">setMaxActiveTasks()</a> and <a class="el" href="class_t_thread_1_1_executor.html#a260fbe2faa1ee57f2042a03aaf30ec1b">setMaxActiveLoad()</a> methods, both granting the possibility to bound the execution of tasks to custom maximum conditions. For example, use setMaxActiveTasks(1) to force the execution of 1 task only at a time, or setMaxActiveLoad(100) to set a single CPU core available for the group.</p>
<dl class="section see"><dt>See also</dt><dd><b><a class="el" href="class_t_thread_1_1_runnable.html">Runnable</a></b> class documentation. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af10e2be4ceafc43c65cb888d14a519de" name="af10e2be4ceafc43c65cb888d14a519de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10e2be4ceafc43c65cb888d14a519de">&#9670;&nbsp;</a></span>Executor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor::Executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  667</span>: m_id(<span class="keyword">new</span> <a class="code hl_class" href="class_t_thread_1_1_executor_id.html">ExecutorId</a>) { m_id-&gt;addRef(); }</div>
<div class="ttc" id="aclass_t_thread_1_1_executor_id_html"><div class="ttname"><a href="class_t_thread_1_1_executor_id.html">TThread::ExecutorId</a></div><div class="ttdef"><b>Definition:</b> tthread.cpp:223</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa963f22d195d6cf6f410b27243c58194" name="aa963f22d195d6cf6f410b27243c58194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa963f22d195d6cf6f410b27243c58194">&#9670;&nbsp;</a></span>~Executor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TThread::Executor::~Executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  671</span>{ m_id-&gt;release(); }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af31c8db8ac72df4c342e7769e95e2135" name="af31c8db8ac72df4c342e7769e95e2135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31c8db8ac72df4c342e7769e95e2135">&#9670;&nbsp;</a></span>addTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TThread::Executor::addTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">RunnableP</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Submits a task for execution. The task is executed according to its task load, insertion time and scheduling priority. </p>
<div class="fragment"><div class="line"><span class="lineno">  804</span>                                     {</div>
<div class="line"><span class="lineno">  805</span>  {</div>
<div class="line"><span class="lineno">  806</span>    <span class="keywordflow">if</span> (task-&gt;m_id)  <span class="comment">// Must be done outside transition lock, since eventually</span></div>
<div class="line"><span class="lineno">  807</span>      task-&gt;m_id-&gt;release();  <span class="comment">// invoked ~ExecutorId will lock it</span></div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span>    <span class="comment">// Updating tasks and workers list - lock against state transitions</span></div>
<div class="line"><span class="lineno">  810</span>    QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  811</span> </div>
<div class="line"><span class="lineno">  812</span>    task-&gt;m_id = m_id;</div>
<div class="line"><span class="lineno">  813</span>    m_id-&gt;addRef();</div>
<div class="line"><span class="lineno">  814</span> </div>
<div class="line"><span class="lineno">  815</span>    globalImp-&gt;insertTask(task-&gt;<a class="code hl_function" href="class_t_thread_1_1_runnable.html#a7e52533850da5433f3075d3d032182c1">schedulingPriority</a>(), task);</div>
<div class="line"><span class="lineno">  816</span>  }</div>
<div class="line"><span class="lineno">  817</span> </div>
<div class="line"><span class="lineno">  818</span>  <span class="comment">// If addTask is called in the main thread, the emit works directly -</span></div>
<div class="line"><span class="lineno">  819</span>  <span class="comment">// so it is necessary to unlock the mutex *before* emitting the refresh.</span></div>
<div class="line"><span class="lineno">  820</span>  globalImpSlots-&gt;emitRefreshAssignments();</div>
<div class="line"><span class="lineno">  821</span>}</div>
<div class="ttc" id="aclass_t_thread_1_1_runnable_html_a7e52533850da5433f3075d3d032182c1"><div class="ttname"><a href="class_t_thread_1_1_runnable.html#a7e52533850da5433f3075d3d032182c1">TThread::Runnable::schedulingPriority</a></div><div class="ttdeci">virtual int schedulingPriority()</div><div class="ttdef"><b>Definition:</b> tthread.cpp:394</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="#l00394">TThread::Runnable::schedulingPriority()</a>.</p>

</div>
</div>
<a id="a3ebba69410a233ff1e5774d7e4d1246f" name="a3ebba69410a233ff1e5774d7e4d1246f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebba69410a233ff1e5774d7e4d1246f">&#9670;&nbsp;</a></span>cancelAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::cancelAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the task manager of all tasks added by this <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> and emits the <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">Runnable::canceled</a> signal for each of them. The same specifications described in the <b>removeTask</b> method apply here. </p><dl class="section see"><dt>See also</dt><dd><b><a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">Runnable::canceled</a></b> signal and the <b><a class="el" href="class_t_thread_1_1_executor.html#a6aabf03f90569a0fceb86f5a3d054c9b">removeTask</a></b> method. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  860</span>                         {</div>
<div class="line"><span class="lineno">  861</span>  <span class="comment">// Updating tasks list - lock against state transitions</span></div>
<div class="line"><span class="lineno">  862</span>  QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  863</span> </div>
<div class="line"><span class="lineno">  864</span>  <span class="comment">// Clear the tasks chronologically. So, first check currently working</span></div>
<div class="line"><span class="lineno">  865</span>  <span class="comment">// tasks.</span></div>
<div class="line"><span class="lineno">  866</span>  std::set&lt;Worker *&gt;::iterator it;</div>
<div class="line"><span class="lineno">  867</span>  <span class="keywordflow">for</span> (it = globalImp-&gt;m_workers.begin(); it != globalImp-&gt;m_workers.end();</div>
<div class="line"><span class="lineno">  868</span>       ++it) {</div>
<div class="line"><span class="lineno">  869</span>    <a class="code hl_class" href="class_t_smart_pointer_t.html">RunnableP</a> task = (*it)-&gt;m_task;</div>
<div class="line"><span class="lineno">  870</span>    <span class="keywordflow">if</span> (task &amp;&amp; task-&gt;m_id == m_id) Q_EMIT task-&gt;<a class="code hl_signal" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled</a>(task);</div>
<div class="line"><span class="lineno">  871</span>  }</div>
<div class="line"><span class="lineno">  872</span> </div>
<div class="line"><span class="lineno">  873</span>  <span class="comment">// Finally, clear the global tasks list from all tasks inserted by this</span></div>
<div class="line"><span class="lineno">  874</span>  <span class="comment">// executor</span></div>
<div class="line"><span class="lineno">  875</span>  <span class="comment">// NOTE: An easier way here?</span></div>
<div class="line"><span class="lineno">  876</span>  QMutableMapIterator&lt;int, RunnableP&gt; jt(globalImp-&gt;m_tasks);</div>
<div class="line"><span class="lineno">  877</span>  <span class="keywordflow">while</span> (jt.hasNext()) {</div>
<div class="line"><span class="lineno">  878</span>    jt.next();</div>
<div class="line"><span class="lineno">  879</span>    <span class="keywordflow">if</span> (jt.value()-&gt;m_id == m_id) {</div>
<div class="line"><span class="lineno">  880</span>      <a class="code hl_class" href="class_t_smart_pointer_t.html">RunnableP</a> task = jt.value();</div>
<div class="line"><span class="lineno">  881</span>      Q_EMIT task-&gt;<a class="code hl_signal" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled</a>(task);</div>
<div class="line"><span class="lineno">  882</span>      jt.remove();</div>
<div class="line"><span class="lineno">  883</span>    }</div>
<div class="line"><span class="lineno">  884</span>  }</div>
<div class="line"><span class="lineno">  885</span>}</div>
<div class="ttc" id="aclass_t_smart_pointer_t_html"><div class="ttname"><a href="class_t_smart_pointer_t.html">TSmartPointerT&lt; Runnable &gt;</a></div></div>
<div class="ttc" id="aclass_t_thread_1_1_runnable_html_a87a003e7e55636146017bd05df73531a"><div class="ttname"><a href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">TThread::Runnable::canceled</a></div><div class="ttdeci">void canceled(TThread::RunnableP sender)</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">TThread::Runnable::canceled()</a>.</p>

</div>
</div>
<a id="ab4f19cebb2e9ffa04ef22aec42d402b7" name="ab4f19cebb2e9ffa04ef22aec42d402b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f19cebb2e9ffa04ef22aec42d402b7">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This static method declares the use of the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a>'s task manager into the application code. Be sure to use it according to the following rules: </p><ul>
<li>
Only QCoreApplications or QApplications may use Executors. </li>
<li>
This method must be invoked in a thread which performs constant Qt event processing - like the main loop of interactive GUI applications. </li>
<li>
No task processing is allowed after event processing stops. </li>
</ul>
<div class="fragment"><div class="line"><span class="lineno">  684</span>                    {</div>
<div class="line"><span class="lineno">  685</span>  <span class="comment">// If no global ExecutorImp exists, allocate it now. You may not move this</span></div>
<div class="line"><span class="lineno">  686</span>  <span class="comment">// to a static declaration, since ExecutorImpSlots&#39;s connections must be</span></div>
<div class="line"><span class="lineno">  687</span>  <span class="comment">// made once the QCoreApplication has been constructed.</span></div>
<div class="line"><span class="lineno">  688</span>  <span class="keywordflow">if</span> (!globalImp) {</div>
<div class="line"><span class="lineno">  689</span>    globalImp      = <span class="keyword">new</span> <a class="code hl_class" href="class_t_thread_1_1_executor_imp.html">ExecutorImp</a>;</div>
<div class="line"><span class="lineno">  690</span>    globalImpSlots = <span class="keyword">new</span> <a class="code hl_class" href="class_t_thread_1_1_executor_imp_slots.html">ExecutorImpSlots</a>;</div>
<div class="line"><span class="lineno">  691</span>  }</div>
<div class="line"><span class="lineno">  692</span> </div>
<div class="line"><span class="lineno">  693</span>  qRegisterMetaType&lt;TThread::RunnableP&gt;(<span class="stringliteral">&quot;TThread::RunnableP&quot;</span>);</div>
<div class="line"><span class="lineno">  694</span>}</div>
<div class="ttc" id="aclass_t_thread_1_1_executor_imp_html"><div class="ttname"><a href="class_t_thread_1_1_executor_imp.html">TThread::ExecutorImp</a></div><div class="ttdef"><b>Definition:</b> tthread.cpp:257</div></div>
<div class="ttc" id="aclass_t_thread_1_1_executor_imp_slots_html"><div class="ttname"><a href="class_t_thread_1_1_executor_imp_slots.html">TThread::ExecutorImpSlots</a></div><div class="ttdef"><b>Definition:</b> tthreadp.h:50</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a114387a08ab8e53bdbbc30e2f53a336b" name="a114387a08ab8e53bdbbc30e2f53a336b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114387a08ab8e53bdbbc30e2f53a336b">&#9670;&nbsp;</a></span>maxActiveLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executor::maxActiveLoad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  925</span>                                  {</div>
<div class="line"><span class="lineno">  926</span>  QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  927</span>  <span class="keywordflow">return</span> m_id-&gt;m_maxActiveLoad;</div>
<div class="line"><span class="lineno">  928</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a966129289d00b7539df5f1b85c41a369" name="a966129289d00b7539df5f1b85c41a369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966129289d00b7539df5f1b85c41a369">&#9670;&nbsp;</a></span>maxActiveTasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Executor::maxActiveTasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  908</span>                                   {</div>
<div class="line"><span class="lineno">  909</span>  QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  910</span>  <span class="keywordflow">return</span> m_id-&gt;m_maxActiveTasks;</div>
<div class="line"><span class="lineno">  911</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6aabf03f90569a0fceb86f5a3d054c9b" name="a6aabf03f90569a0fceb86f5a3d054c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aabf03f90569a0fceb86f5a3d054c9b">&#9670;&nbsp;</a></span>removeTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::removeTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_smart_pointer_t.html">RunnableP</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the given task from scheduled execution and emits its <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">Runnable::canceled</a> signal. Tasks already under execution are not stopped by this method - although the canceled signal is still emitted. It has no effect if the task is not currently under the task manager's control. </p><dl class="section see"><dt>See also</dt><dd><b><a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">Runnable::canceled</a></b> signal and the <b><a class="el" href="class_t_thread_1_1_executor.html#a3ebba69410a233ff1e5774d7e4d1246f">cancelAll</a></b> method. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  831</span>                                        {</div>
<div class="line"><span class="lineno">  832</span>  <span class="comment">// If the task does not belong to this Executor, quit.</span></div>
<div class="line"><span class="lineno">  833</span>  <span class="keywordflow">if</span> (task-&gt;m_id != m_id) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  834</span> </div>
<div class="line"><span class="lineno">  835</span>  <span class="comment">// Updating tasks list - lock against state transitions</span></div>
<div class="line"><span class="lineno">  836</span>  QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  837</span> </div>
<div class="line"><span class="lineno">  838</span>  <span class="comment">// Then, look in the global queue - if it is found, emiminate the task and</span></div>
<div class="line"><span class="lineno">  839</span>  <span class="comment">// send the canceled signal.</span></div>
<div class="line"><span class="lineno">  840</span>  <span class="keywordflow">if</span> (globalImp-&gt;m_tasks.remove(task-&gt;m_schedulingPriority, task)) {</div>
<div class="line"><span class="lineno">  841</span>    Q_EMIT task-&gt;<a class="code hl_signal" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled</a>(task);</div>
<div class="line"><span class="lineno">  842</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  843</span>  }</div>
<div class="line"><span class="lineno">  844</span> </div>
<div class="line"><span class="lineno">  845</span>  <span class="comment">// Finally, the task may be running - look in workers.</span></div>
<div class="line"><span class="lineno">  846</span>  std::set&lt;Worker *&gt; &amp;workers = globalImp-&gt;m_workers;</div>
<div class="line"><span class="lineno">  847</span>  std::set&lt;Worker *&gt;::iterator it;</div>
<div class="line"><span class="lineno">  848</span>  <span class="keywordflow">for</span> (it = workers.begin(); it != workers.end(); ++it)</div>
<div class="line"><span class="lineno">  849</span>    <span class="keywordflow">if</span> (task &amp;&amp; (*it)-&gt;m_task == task) Q_EMIT task-&gt;<a class="code hl_signal" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled</a>(task);</div>
<div class="line"><span class="lineno">  850</span> </div>
<div class="line"><span class="lineno">  851</span>  <span class="comment">// No need to refresh - tasks were eventually decremented...</span></div>
<div class="line"><span class="lineno">  852</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">TThread::Runnable::canceled()</a>.</p>

</div>
</div>
<a id="a02c4c637864647ce22be391919049d3a" name="a02c4c637864647ce22be391919049d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c4c637864647ce22be391919049d3a">&#9670;&nbsp;</a></span>setDedicatedThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::setDedicatedThreads </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dedicated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>persistent</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the use of dedicated threads for the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a>'s task group. </p>
<p >By default a worker thread attempts adoption of <a class="el" href="class_t_thread_1_1_runnable.html">Runnable</a> tasks without regard to the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> that performed the submission. This helps in stabilizing the number of threads that are created and destroyed by the task manager - but may be a problem in some cases. Using this method the user can explicitly tell the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> to seize the ownership of worker threads assigned to its tasks, so that they will not try adoption of external tasks but instead remain focused on <a class="el" href="class_t_thread_1_1_executor.html">Executor</a>'s tasks only. An optional <b>persistent</b> parameter may be passed, which specifies if dedicated threads should remain sleeping or should rather die when no processable tasks from the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> are found. This method is especially helpful in two occasions: </p><ul>
<li>
The <a class="el" href="class_t_thread_1_1_executor.html">Executor</a>'s tasks use thread-specific data such as QThreadStorages, which may be recycled among different tasks. </li>
<li>
The <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> receives tasks at a frequent rate, but mostly ends each one before another one is submitted - resulting in a continuous thread turnover. </li>
</ul>
<div class="fragment"><div class="line"><span class="lineno">  791</span>                                                                  {</div>
<div class="line"><span class="lineno">  792</span>  QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  793</span> </div>
<div class="line"><span class="lineno">  794</span>  m_id-&gt;m_dedicatedThreads  = dedicated;</div>
<div class="line"><span class="lineno">  795</span>  m_id-&gt;m_persistentThreads = persistent;</div>
<div class="line"><span class="lineno">  796</span> </div>
<div class="line"><span class="lineno">  797</span>  m_id-&gt;refreshDedicatedList();</div>
<div class="line"><span class="lineno">  798</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a260fbe2faa1ee57f2042a03aaf30ec1b" name="a260fbe2faa1ee57f2042a03aaf30ec1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260fbe2faa1ee57f2042a03aaf30ec1b">&#9670;&nbsp;</a></span>setMaxActiveLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::setMaxActiveLoad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxActiveLoad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Declares a maximum overall task load for the tasks added by this <a class="el" href="class_t_thread_1_1_executor.html">Executor</a>. <b>NOTE:</b> The same remark for <a class="el" href="class_t_thread_1_1_executor.html#a85231531a2fa273db401f090c9aba4ea">setMaxActiveTasks()</a> holds here. </p>
<div class="fragment"><div class="line"><span class="lineno">  917</span>                                                 {</div>
<div class="line"><span class="lineno">  918</span>  QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  919</span> </div>
<div class="line"><span class="lineno">  920</span>  m_id-&gt;m_maxActiveLoad = maxActiveLoad;</div>
<div class="line"><span class="lineno">  921</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85231531a2fa273db401f090c9aba4ea" name="a85231531a2fa273db401f090c9aba4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85231531a2fa273db401f090c9aba4ea">&#9670;&nbsp;</a></span>setMaxActiveTasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::setMaxActiveTasks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxActiveTasks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Declares that only a certain number of tasks added by this <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> may be processed simultaneously. The default is 1 - meaning that tasks added to the executor are completely serialized. A negative task number disables any form of task serialization. <b>NOTE:</b> Currently, tasks that do not satisfy this condition avoid blocking execution of tasks not added by the same <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> - even if they were scheduled for later execution. </p>
<div class="fragment"><div class="line"><span class="lineno">  897</span>                                                   {</div>
<div class="line"><span class="lineno">  898</span>  QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  899</span> </div>
<div class="line"><span class="lineno">  900</span>  <span class="keywordflow">if</span> (maxActiveTasks &lt;= 0)</div>
<div class="line"><span class="lineno">  901</span>    m_id-&gt;m_maxActiveTasks = (std::numeric_limits&lt;int&gt;::max)();</div>
<div class="line"><span class="lineno">  902</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  903</span>    m_id-&gt;m_maxActiveTasks = maxActiveTasks;</div>
<div class="line"><span class="lineno">  904</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad11a0430a6be6601a2e5aa34a10c3b60" name="ad11a0430a6be6601a2e5aa34a10c3b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11a0430a6be6601a2e5aa34a10c3b60">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This static method, which <b>must</b> be invoked in the controller thread, declares termination of all Executor-based components, forcing the execution of tasks submitted by any <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> to quit as soon as possible in a safe way. When the shutdown method is invoked, the task manager first emits a canceled() signal for all the tasks that were submitted to it, independently from the <a class="el" href="class_t_thread_1_1_executor.html">Executor</a> that performed the submission; then, tasks that are still active once all the cancellation signals were delivered further receive a terminated() signal informing them that they must provide code termination (or at least remain silent in a safe state until the application quits). <b>NOTE:</b> Observe that this method does not explicitly wait for all the tasks to terminate - this depends on the code connected to the terminated() signal and is under the user's responsibility (see the remarks specified in started() signal description); if this is the intent and the terminated slot is invoked in the controller thread, you should remember to implement a local event loop in it (so that event processing is still performed) and wait there until the first finished() or catched() slot make it quit. </p>
<div class="fragment"><div class="line"><span class="lineno">  725</span>                        {</div>
<div class="line"><span class="lineno">  726</span>  {</div>
<div class="line"><span class="lineno">  727</span>    <span class="comment">// Updating tasks list - lock against state transitions</span></div>
<div class="line"><span class="lineno">  728</span>    QMutexLocker transitionLocker(&amp;globalImp-&gt;m_transitionMutex);</div>
<div class="line"><span class="lineno">  729</span> </div>
<div class="line"><span class="lineno">  730</span>    shutdownVar = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  731</span> </div>
<div class="line"><span class="lineno">  732</span>    <span class="comment">// Cancel all tasks  - first the active ones</span></div>
<div class="line"><span class="lineno">  733</span>    std::set&lt;Worker *&gt;::iterator it;</div>
<div class="line"><span class="lineno">  734</span>    <span class="keywordflow">for</span> (it = globalImp-&gt;m_workers.begin(); it != globalImp-&gt;m_workers.end();</div>
<div class="line"><span class="lineno">  735</span>         ++it) {</div>
<div class="line"><span class="lineno">  736</span>      <a class="code hl_class" href="class_t_smart_pointer_t.html">RunnableP</a> task = (*it)-&gt;m_task;</div>
<div class="line"><span class="lineno">  737</span>      <span class="keywordflow">if</span> (task) Q_EMIT task-&gt;<a class="code hl_signal" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled</a>(task);</div>
<div class="line"><span class="lineno">  738</span>    }</div>
<div class="line"><span class="lineno">  739</span> </div>
<div class="line"><span class="lineno">  740</span>    <span class="comment">// Finally, deal with the global queue tasks</span></div>
<div class="line"><span class="lineno">  741</span>    QMutableMapIterator&lt;int, RunnableP&gt; jt(globalImp-&gt;m_tasks);</div>
<div class="line"><span class="lineno">  742</span>    <span class="keywordflow">while</span> (jt.hasNext()) {</div>
<div class="line"><span class="lineno">  743</span>      jt.next();</div>
<div class="line"><span class="lineno">  744</span>      <a class="code hl_class" href="class_t_smart_pointer_t.html">RunnableP</a> task = jt.value();</div>
<div class="line"><span class="lineno">  745</span>      Q_EMIT task-&gt;<a class="code hl_signal" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">canceled</a>(task);</div>
<div class="line"><span class="lineno">  746</span>      jt.remove();</div>
<div class="line"><span class="lineno">  747</span>    }</div>
<div class="line"><span class="lineno">  748</span> </div>
<div class="line"><span class="lineno">  749</span>    <span class="comment">// Now, send the terminate() signal to all active tasks</span></div>
<div class="line"><span class="lineno">  750</span>    <span class="keywordflow">for</span> (it = globalImp-&gt;m_workers.begin(); it != globalImp-&gt;m_workers.end();</div>
<div class="line"><span class="lineno">  751</span>         ++it) {</div>
<div class="line"><span class="lineno">  752</span>      <a class="code hl_class" href="class_t_smart_pointer_t.html">RunnableP</a> task = (*it)-&gt;m_task;</div>
<div class="line"><span class="lineno">  753</span>      <span class="keywordflow">if</span> (task) Q_EMIT task-&gt;<a class="code hl_signal" href="class_t_thread_1_1_runnable.html#afda69c2f2eb6df8d30d7668a4cdd60da">terminated</a>(task);</div>
<div class="line"><span class="lineno">  754</span>    }</div>
<div class="line"><span class="lineno">  755</span>  }</div>
<div class="line"><span class="lineno">  756</span> </div>
<div class="line"><span class="lineno">  757</span>  <span class="comment">// Just placing a convenience processEvents() to make sure that queued slots</span></div>
<div class="line"><span class="lineno">  758</span>  <span class="comment">// invoked by the</span></div>
<div class="line"><span class="lineno">  759</span>  <span class="comment">// signals above are effectively invoked in this method - without having to</span></div>
<div class="line"><span class="lineno">  760</span>  <span class="comment">// return to an event loop.</span></div>
<div class="line"><span class="lineno">  761</span>  QCoreApplication::processEvents();</div>
<div class="line"><span class="lineno">  762</span>}</div>
<div class="ttc" id="aclass_t_thread_1_1_runnable_html_afda69c2f2eb6df8d30d7668a4cdd60da"><div class="ttname"><a href="class_t_thread_1_1_runnable.html#afda69c2f2eb6df8d30d7668a4cdd60da">TThread::Runnable::terminated</a></div><div class="ttdeci">void terminated(TThread::RunnableP sender)</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_t_thread_1_1_runnable.html#a87a003e7e55636146017bd05df73531a">TThread::Runnable::canceled()</a>, and <a class="el" href="class_t_thread_1_1_runnable.html#afda69c2f2eb6df8d30d7668a4cdd60da">TThread::Runnable::terminated()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af022abc71323b07be5460515acab8737" name="af022abc71323b07be5460515acab8737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af022abc71323b07be5460515acab8737">&#9670;&nbsp;</a></span>ExecutorImp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_t_thread_1_1_executor_imp.html">ExecutorImp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>E:/opentoonz/toonz/sources/include/<a class="el" href="">tthread.h</a></li>
<li>E:/opentoonz/toonz/sources/common/tcore/<a class="el" href="">tthread.cpp</a></li>
<li>E:/opentoonz/toonz/sources/toonzfarm/tnzcore_stuff/<a class="el" href="">tthread.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
