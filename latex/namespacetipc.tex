\hypertarget{namespacetipc}{}\doxysection{tipc Namespace Reference}
\label{namespacetipc}\index{tipc@{tipc}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classtipc_1_1_default_message_parser}{Default\+Message\+Parser}}
\item 
class \mbox{\hyperlink{classtipc_1_1_message}{Message}}
\item 
class \mbox{\hyperlink{classtipc_1_1_message_parser}{Message\+Parser}}
\item 
class \mbox{\hyperlink{classtipc_1_1_server}{Server}}
\item 
class \mbox{\hyperlink{classtipc_1_1_sh_mem_reader}{Sh\+Mem\+Reader}}
\item 
class \mbox{\hyperlink{classtipc_1_1_sh_mem_writer}{Sh\+Mem\+Writer}}
\item 
class \mbox{\hyperlink{classtipc_1_1_socket_controller}{Socket\+Controller}}
\item 
class \mbox{\hyperlink{classtipc_1_1_stream}{Stream}}
\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bfseries Def\+Msg\+Enum} \{ \newline
{\bfseries SHMEM\+\_\+\+REQUEST}
, {\bfseries SHMEM\+\_\+\+RELEASE}
, {\bfseries TMPFILE\+\_\+\+REQUEST}
, {\bfseries TMPFILE\+\_\+\+RELEASE}
, \newline
{\bfseries QUIT\+\_\+\+ON\+\_\+\+ERROR}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classtipc_1_1_message}{Message}} \& \mbox{\hyperlink{namespacetipc_a5e4c984d85c07033cb34b44556c2c20f}{clr}} (\mbox{\hyperlink{classtipc_1_1_message}{Message}} \&msg)
\item 
\mbox{\hyperlink{classtipc_1_1_message}{Message}} \& \mbox{\hyperlink{namespacetipc_a071d08f704357ddb8b9cace457ca60e3}{reset}} (\mbox{\hyperlink{classtipc_1_1_message}{Message}} \&msg)
\item 
DVAPI bool \mbox{\hyperlink{namespacetipc_a6804bfb80699b3a587d18284a672481a}{start\+Background\+Process}} (QString cmdline)
\item 
DVAPI QString \mbox{\hyperlink{namespacetipc_a87c10c7c68db698158baefda97b5a139}{application\+Specific\+Server\+Name}} (QString srv\+Name)
\item 
DVAPI bool \mbox{\hyperlink{namespacetipc_aecf411559c63f5b9e133543db81d15a2}{start\+Slave\+Connection}} (QLocal\+Socket $\ast$socket, QString srv\+Name, int msecs=-\/1, QString cmdline=QString(), QString thread\+Name=QString())
\item 
DVAPI bool \mbox{\hyperlink{namespacetipc_a2f7d4a5a27b23fa071270bcb047ccbed}{start\+Slave\+Server}} (QString srv\+Name, QString cmdline)
\item 
DVAPI QString \mbox{\hyperlink{namespacetipc_af7c4513a3ce3661246acec7de89ab6f0}{read\+Message}} (\mbox{\hyperlink{classtipc_1_1_stream}{Stream}} \&stream, \mbox{\hyperlink{classtipc_1_1_message}{Message}} \&msg, int msecs=-\/1)
\item 
DVAPI QString \mbox{\hyperlink{namespacetipc_abc7c7a75b130fd8514ad31f25e040418}{read\+Message\+NB}} (\mbox{\hyperlink{classtipc_1_1_stream}{Stream}} \&stream, \mbox{\hyperlink{classtipc_1_1_message}{Message}} \&msg, int msecs=-\/1, QEvent\+Loop\+::\+Process\+Events\+Flag flag=QEvent\+Loop\+::\+All\+Events)
\item 
DVAPI int \mbox{\hyperlink{namespacetipc_a24ab553bd0dde70187d1bf3898573a35}{shm\+\_\+max\+Segment\+Size}} ()
\begin{DoxyCompactList}\small\item\em Returns the maximum size of a shared memory segment allowed by the system. \end{DoxyCompactList}\item 
DVAPI int \mbox{\hyperlink{namespacetipc_a8de9c57a17b010d88d87c4134ef4818d}{shm\+\_\+max\+Segment\+Count}} ()
\begin{DoxyCompactList}\small\item\em Returns the maximum number of shared segments allowed by the system. \end{DoxyCompactList}\item 
DVAPI int \mbox{\hyperlink{namespacetipc_ae0f9cce65f73f00948e1b82bb8cc185a}{shm\+\_\+max\+Shared\+Pages}} ()
\item 
DVAPI int \mbox{\hyperlink{namespacetipc_a4860847dda94ee5bcb51374e859e076c}{shm\+\_\+max\+Shared\+Count}} ()
\item 
DVAPI void \mbox{\hyperlink{namespacetipc_aee1cf233a1829eb6102db2103d730bee}{shm\+\_\+set}} (int max\+Segment\+Size, int max\+Segment\+Count, int max\+Shared\+Size, int max\+Shared\+Count)
\item 
DVAPI QString \mbox{\hyperlink{namespacetipc_a136469c8fb1b3c40c59ab0892b388bf4}{unique\+Id}} ()
\item 
DVAPI int \mbox{\hyperlink{namespacetipc_a69f3a9b4df074628fa5e1cba5db511ae}{create}} (QShared\+Memory \&shmem, int size, bool strict\+Size=false)
\item 
DVAPI bool \mbox{\hyperlink{namespacetipc_a30132f99c3439636d6c729f4578675b0}{read\+Sh\+Mem\+Buffer}} (\mbox{\hyperlink{classtipc_1_1_stream}{Stream}} \&stream, \mbox{\hyperlink{classtipc_1_1_message}{Message}} \&msg, \mbox{\hyperlink{classtipc_1_1_sh_mem_reader}{Sh\+Mem\+Reader}} $\ast$data\+Reader)
\item 
DVAPI bool \mbox{\hyperlink{namespacetipc_a20c43aa530b558c7dcb3149d8901bdc4}{write\+Sh\+Mem\+Buffer}} (\mbox{\hyperlink{classtipc_1_1_stream}{Stream}} \&stream, \mbox{\hyperlink{classtipc_1_1_message}{Message}} \&msg, int buf\+Size, \mbox{\hyperlink{classtipc_1_1_sh_mem_writer}{Sh\+Mem\+Writer}} $\ast$data\+Writer)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The tipc namespace provides facilities to deal with inter-\/process communication tasks. The tipc inner workings make use of Qt\textquotesingle{}s QLocal\+Server/\+QLocal\+Socket standard ipc framework; but moreover, it helps the user hiding some of the intricacies of ipc management. \textbackslash{}m \textbackslash{}m The tipc model assumes there is a server process running to which several processes can connect to in order to require services through appropriate server-\/supported commands. Communication happens by sending \mbox{\hyperlink{classtipc_1_1_message}{tipc\+::\+Message}} instances through a \mbox{\hyperlink{classtipc_1_1_stream}{tipc\+::\+Stream}} constructed on a QLocal\+Socket device connected to the server in a Qt-\/like manner. ~\newline
~\newline
 Messages encapsulate an atomic communication that must be received in its entirety to be understood by the receiver. Any message sent by a client must provide a QString header to identify the message type, which must be recognizable by the server side to be appropriately parsed. Each message understood by the server process will be replied with a message to ensure the client that the parsing has been completed. ~\newline
~\newline
 A \mbox{\hyperlink{classtipc_1_1_server}{tipc\+::\+Server}} instance must be used on the server side to process supported messages. \mbox{\hyperlink{classtipc_1_1_message}{Message}} parsing is responsibility of specific subclasses of the \mbox{\hyperlink{classtipc_1_1_message_parser}{tipc\+::\+Message\+Parser}} base class, which must be implemented and added to the server. ~\newline
 ~\newline
 Tipc standard messages include requests for temporary files or shared memory segments, which must be released after use. 

\doxysubsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespacetipc_a5d3ab854949014a8bb0866138bca12a4}\label{namespacetipc_a5d3ab854949014a8bb0866138bca12a4}} 
\index{tipc@{tipc}!DefMsgEnum@{DefMsgEnum}}
\index{DefMsgEnum@{DefMsgEnum}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{DefMsgEnum}{DefMsgEnum}}
{\footnotesize\ttfamily enum tipc\+::\+Def\+Msg\+Enum}


\begin{DoxyCode}{0}
\DoxyCodeLine{00049                 \{}
\DoxyCodeLine{00050   SHMEM\_REQUEST,}
\DoxyCodeLine{00051   SHMEM\_RELEASE,}
\DoxyCodeLine{00052   TMPFILE\_REQUEST,}
\DoxyCodeLine{00053   TMPFILE\_RELEASE,}
\DoxyCodeLine{00054   QUIT\_ON\_ERROR}
\DoxyCodeLine{00055 \};}

\end{DoxyCode}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacetipc_a87c10c7c68db698158baefda97b5a139}\label{namespacetipc_a87c10c7c68db698158baefda97b5a139}} 
\index{tipc@{tipc}!applicationSpecificServerName@{applicationSpecificServerName}}
\index{applicationSpecificServerName@{applicationSpecificServerName}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{applicationSpecificServerName()}{applicationSpecificServerName()}}
{\footnotesize\ttfamily QString tipc\+::application\+Specific\+Server\+Name (\begin{DoxyParamCaption}\item[{QString}]{srv\+Name }\end{DoxyParamCaption})}

Appends the invoking process\textquotesingle{} pid to the passed srv\+Name. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00257                                                            \{}
\DoxyCodeLine{00258   \textcolor{keywordflow}{return} srvName + QString::number(QCoreApplication::applicationPid());}
\DoxyCodeLine{00259 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetipc_a5e4c984d85c07033cb34b44556c2c20f}\label{namespacetipc_a5e4c984d85c07033cb34b44556c2c20f}} 
\index{tipc@{tipc}!clr@{clr}}
\index{clr@{clr}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{clr()}{clr()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classtipc_1_1_message}{Message}} \& tipc\+::clr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtipc_1_1_message}{Message}} \&}]{msg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00175                                   \{}
\DoxyCodeLine{00176   msg.clear();}
\DoxyCodeLine{00177   \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{00178 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetipc_a69f3a9b4df074628fa5e1cba5db511ae}\label{namespacetipc_a69f3a9b4df074628fa5e1cba5db511ae}} 
\index{tipc@{tipc}!create@{create}}
\index{create@{create}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{create()}{create()}}
{\footnotesize\ttfamily int tipc\+::create (\begin{DoxyParamCaption}\item[{QShared\+Memory \&}]{shmem,  }\item[{int}]{size,  }\item[{bool}]{strict\+Size = {\ttfamily false} }\end{DoxyParamCaption})}

Creates a shared memory segment for passed QShared\+Memory.

This function attempts creation of a shared memory segment in the form of Qt\textquotesingle{}s QShared\+Memory, with the following {\bfseries{UNIX-\/specific}} distinctions\+:

If the segment size is beyond that supported by the system, the function can be set to either fail or return a segment with the maximum supported size. \texorpdfstring{$<$}{<}\textbackslash{}\+LI\texorpdfstring{$>$}{>}

Unlike QShared\+Memory\+::create, this function attempts to reclaim an already existing memory id before creating a new one. \texorpdfstring{$<$}{<}\textbackslash{}\+LI\texorpdfstring{$>$}{>} 
\begin{DoxyCode}{0}
\DoxyCodeLine{00588                                                                 \{}
\DoxyCodeLine{00589   \textcolor{keywordtype}{bool} ok, retried = \textcolor{keyword}{false};}
\DoxyCodeLine{00590 }
\DoxyCodeLine{00591   \textcolor{keywordflow}{if} (!strictSize) size = std::min(size, (\textcolor{keywordtype}{int})\mbox{\hyperlink{namespacetipc_a24ab553bd0dde70187d1bf3898573a35}{shm\_maxSegmentSize}}());}
\DoxyCodeLine{00592 }
\DoxyCodeLine{00593   tipc\_debug(qDebug() << \textcolor{stringliteral}{"{}shMem create: size ="{}} << size);}
\DoxyCodeLine{00594 }
\DoxyCodeLine{00595 retry:}
\DoxyCodeLine{00596 }
\DoxyCodeLine{00597   ok = shmem.create(size);}
\DoxyCodeLine{00598   \textcolor{keywordflow}{if} (!ok) \{}
\DoxyCodeLine{00599     tipc\_debug(qDebug() << \textcolor{stringliteral}{"{}Error: Shared Segment could not be created: \#"{}}}
\DoxyCodeLine{00600                         << shmem.errorString());}
\DoxyCodeLine{00601 }
\DoxyCodeLine{00602     \textcolor{comment}{// Unix-\/specific error recovery follows. See Qt's docs about it.}}
\DoxyCodeLine{00603 }
\DoxyCodeLine{00604     \textcolor{comment}{// Try to recover error \#AlreadyExists -\/ supposedly, the server crashed in a}}
\DoxyCodeLine{00605     \textcolor{comment}{// previous instance.}}
\DoxyCodeLine{00606     \textcolor{comment}{// As shared memory segments that happen to go this way are owned by the}}
\DoxyCodeLine{00607     \textcolor{comment}{// server process with 1}}
\DoxyCodeLine{00608     \textcolor{comment}{// reference count, detaching it now may solve the issue.}}
\DoxyCodeLine{00609     \textcolor{keywordflow}{if} (shmem.error() == QSharedMemory::AlreadyExists \&\& !retried) \{}
\DoxyCodeLine{00610       retried = \textcolor{keyword}{true};  \textcolor{comment}{// We're trying this only once... for now it works.}}
\DoxyCodeLine{00611       shmem.attach();}
\DoxyCodeLine{00612       shmem.detach();}
\DoxyCodeLine{00613       \textcolor{keywordflow}{goto} retry;}
\DoxyCodeLine{00614     \}}
\DoxyCodeLine{00615 }
\DoxyCodeLine{00616     \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{00617   \}}
\DoxyCodeLine{00618 }
\DoxyCodeLine{00619   \textcolor{keywordflow}{return} size;}
\DoxyCodeLine{00620 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00463}{shm\+\_\+max\+Segment\+Size()}}.



Referenced by \mbox{\hyperlink{l00627}{write\+Sh\+Mem\+Buffer()}}.

\mbox{\Hypertarget{namespacetipc_af7c4513a3ce3661246acec7de89ab6f0}\label{namespacetipc_af7c4513a3ce3661246acec7de89ab6f0}} 
\index{tipc@{tipc}!readMessage@{readMessage}}
\index{readMessage@{readMessage}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{readMessage()}{readMessage()}}
{\footnotesize\ttfamily QString tipc\+::read\+Message (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtipc_1_1_stream}{Stream}} \&}]{stream,  }\item[{\mbox{\hyperlink{classtipc_1_1_message}{Message}} \&}]{msg,  }\item[{int}]{msecs = {\ttfamily -\/1} }\end{DoxyParamCaption})}

Waits and reads the next message from stream. This function is mainly a useful macro that encapsulates the following steps in one call\+:

\begin{DoxyItemize}
\item Flush the write buffer (output messages) \item Wait until an input message is completely readable \item Read the message from stream \item Read the first string from the message and return it\end{DoxyItemize}
This function returns an empty QString if the message could not be entirely retrieved from the stream. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00422                                                                  \{}
\DoxyCodeLine{00423   msg.clear();}
\DoxyCodeLine{00424   stream.\mbox{\hyperlink{classtipc_1_1_stream_ae0da21c97a71a36b3e3238d7c7621a75}{flush}}();}
\DoxyCodeLine{00425   \textcolor{keywordflow}{if} (!stream.\mbox{\hyperlink{classtipc_1_1_stream_adcecdfe5a227fa2e64f4fd4d3bb7886b}{readMessage}}(msg, msecs)) \textcolor{keywordflow}{return} QString();}
\DoxyCodeLine{00426 }
\DoxyCodeLine{00427   QString res;}
\DoxyCodeLine{00428   msg >> res;}
\DoxyCodeLine{00429   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{00430 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00206}{tipc\+::\+Stream\+::flush()}}, and \mbox{\hyperlink{l00169}{tipc\+::\+Stream\+::read\+Message()}}.



Referenced by \mbox{\hyperlink{l00682}{read\+Sh\+Mem\+Buffer()}}, \mbox{\hyperlink{l00298}{start\+Slave\+Server()}}, and \mbox{\hyperlink{l00627}{write\+Sh\+Mem\+Buffer()}}.

\mbox{\Hypertarget{namespacetipc_abc7c7a75b130fd8514ad31f25e040418}\label{namespacetipc_abc7c7a75b130fd8514ad31f25e040418}} 
\index{tipc@{tipc}!readMessageNB@{readMessageNB}}
\index{readMessageNB@{readMessageNB}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{readMessageNB()}{readMessageNB()}}
{\footnotesize\ttfamily QString tipc\+::read\+Message\+NB (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtipc_1_1_stream}{Stream}} \&}]{stream,  }\item[{\mbox{\hyperlink{classtipc_1_1_message}{Message}} \&}]{msg,  }\item[{int}]{msecs = {\ttfamily -\/1},  }\item[{QEvent\+Loop\+::\+Process\+Events\+Flag}]{flag = {\ttfamily QEventLoop\+:\+:AllEvents} }\end{DoxyParamCaption})}

The non-\/blocking equivalent to \mbox{\hyperlink{namespacetipc_af7c4513a3ce3661246acec7de89ab6f0}{tipc\+::read\+Message}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00438                                                               \{}
\DoxyCodeLine{00439   msg.clear();}
\DoxyCodeLine{00440   \textcolor{keywordflow}{if} (!stream.\mbox{\hyperlink{classtipc_1_1_stream_a4217859111bd3dab6811bebb10915e4d}{readMessageNB}}(msg, msecs, flag)) \textcolor{keywordflow}{return} QString();}
\DoxyCodeLine{00441 }
\DoxyCodeLine{00442   QString res;}
\DoxyCodeLine{00443   msg >> res;}
\DoxyCodeLine{00444   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{00445 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00186}{tipc\+::\+Stream\+::read\+Message\+NB()}}.

\mbox{\Hypertarget{namespacetipc_a30132f99c3439636d6c729f4578675b0}\label{namespacetipc_a30132f99c3439636d6c729f4578675b0}} 
\index{tipc@{tipc}!readShMemBuffer@{readShMemBuffer}}
\index{readShMemBuffer@{readShMemBuffer}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{readShMemBuffer()}{readShMemBuffer()}}
{\footnotesize\ttfamily bool tipc\+::read\+Sh\+Mem\+Buffer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtipc_1_1_stream}{Stream}} \&}]{stream,  }\item[{\mbox{\hyperlink{classtipc_1_1_message}{Message}} \&}]{msg,  }\item[{\mbox{\hyperlink{classtipc_1_1_sh_mem_reader}{Sh\+Mem\+Reader}} $\ast$}]{data\+Reader }\end{DoxyParamCaption})}

Reads data through a shared memory segment medium. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00683                                                     \{}
\DoxyCodeLine{00684   tipc\_debug(QTime time; time.start(););}
\DoxyCodeLine{00685   tipc\_debug(qDebug(\textcolor{stringliteral}{"{}tipc::readShMemBuffer entry"{}}));}
\DoxyCodeLine{00686 }
\DoxyCodeLine{00687   \textcolor{comment}{// Read the id from stream}}
\DoxyCodeLine{00688   QString res(\mbox{\hyperlink{namespacetipc_af7c4513a3ce3661246acec7de89ab6f0}{tipc::readMessage}}(stream, msg));}
\DoxyCodeLine{00689   \textcolor{keywordflow}{if} (res != \textcolor{stringliteral}{"{}shm"{}}) \{}
\DoxyCodeLine{00690     tipc\_debug(qDebug(\textcolor{stringliteral}{"{}tipc::readShMemBuffer exit (res != \(\backslash\)"{}shm\(\backslash\)"{})"{}}));}
\DoxyCodeLine{00691     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00692   \}}
\DoxyCodeLine{00693 }
\DoxyCodeLine{00694   \textcolor{comment}{// Read message and reply}}
\DoxyCodeLine{00695   QString id, chkStr;}
\DoxyCodeLine{00696   \textcolor{keywordtype}{int} bufSize;}
\DoxyCodeLine{00697   msg >> \textcolor{keywordtype}{id} >> bufSize >> chkStr;}
\DoxyCodeLine{00698 }
\DoxyCodeLine{00699   \textcolor{comment}{// Data is ready to be read -\/ attach to the shared memory segment.}}
\DoxyCodeLine{00700   QSharedMemory shmem(\textcolor{keywordtype}{id});}
\DoxyCodeLine{00701   shmem.attach();}
\DoxyCodeLine{00702   \textcolor{keywordflow}{if} (!shmem.isAttached()) \{}
\DoxyCodeLine{00703     tipc\_debug(qDebug(\textcolor{stringliteral}{"{}tipc::readShMemBuffer exit (shmem not attached)"{}}));}
\DoxyCodeLine{00704     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00705   \}}
\DoxyCodeLine{00706 }
\DoxyCodeLine{00707   \textcolor{comment}{// Start reading from it}}
\DoxyCodeLine{00708   \textcolor{keywordtype}{int} chunkData, remainingData = bufSize;}
\DoxyCodeLine{00709   \textcolor{keywordflow}{while} (\textcolor{keyword}{true}) \{}
\DoxyCodeLine{00710     msg >> chunkData;}
\DoxyCodeLine{00711 }
\DoxyCodeLine{00712     tipc\_debug(QTime xchTime; xchTime.start());}
\DoxyCodeLine{00713     shmem.lock();}
\DoxyCodeLine{00714     remainingData -\/= dataReader-\/>read((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)shmem.data(), chunkData);}
\DoxyCodeLine{00715     shmem.unlock();}
\DoxyCodeLine{00716     tipc\_debug(qDebug() << \textcolor{stringliteral}{"{}exchange time:"{}} << xchTime.elapsed());}
\DoxyCodeLine{00717 }
\DoxyCodeLine{00718     \textcolor{comment}{// Data was read. Inform the writer}}
\DoxyCodeLine{00719     stream << (msg << clr << QString(\textcolor{stringliteral}{"{}ok"{}}));}
\DoxyCodeLine{00720     stream.\mbox{\hyperlink{classtipc_1_1_stream_ae0da21c97a71a36b3e3238d7c7621a75}{flush}}();}
\DoxyCodeLine{00721 }
\DoxyCodeLine{00722     \textcolor{keywordflow}{if} (remainingData <= 0) \textcolor{keywordflow}{break};}
\DoxyCodeLine{00723 }
\DoxyCodeLine{00724     \textcolor{comment}{// Wait for more chunks}}
\DoxyCodeLine{00725     \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacetipc_af7c4513a3ce3661246acec7de89ab6f0}{tipc::readMessage}}(stream, msg) != \textcolor{stringliteral}{"{}chk"{}}) \{}
\DoxyCodeLine{00726       tipc\_debug(}
\DoxyCodeLine{00727           qDebug(\textcolor{stringliteral}{"{}tipc::readShMemBuffer exit (unexpected chunk absence)"{}}));}
\DoxyCodeLine{00728       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00729     \}}
\DoxyCodeLine{00730   \}}
\DoxyCodeLine{00731 }
\DoxyCodeLine{00732   shmem.detach();}
\DoxyCodeLine{00733   tipc\_debug(qDebug(\textcolor{stringliteral}{"{}tipc::readShMemBuffer exit"{}}));}
\DoxyCodeLine{00734   tipc\_debug(qDebug() << \textcolor{stringliteral}{"{}tipc::readShMemBuffer time:"{}} << time.elapsed());}
\DoxyCodeLine{00735   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00736 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00206}{tipc\+::\+Stream\+::flush()}}, and \mbox{\hyperlink{l00422}{read\+Message()}}.

\mbox{\Hypertarget{namespacetipc_a071d08f704357ddb8b9cace457ca60e3}\label{namespacetipc_a071d08f704357ddb8b9cace457ca60e3}} 
\index{tipc@{tipc}!reset@{reset}}
\index{reset@{reset}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classtipc_1_1_message}{Message}} \& tipc\+::reset (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtipc_1_1_message}{Message}} \&}]{msg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00180                                     \{}
\DoxyCodeLine{00181   msg.ds().device()-\/>seek(0);}
\DoxyCodeLine{00182   \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{00183 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetipc_a8de9c57a17b010d88d87c4134ef4818d}\label{namespacetipc_a8de9c57a17b010d88d87c4134ef4818d}} 
\index{tipc@{tipc}!shm\_maxSegmentCount@{shm\_maxSegmentCount}}
\index{shm\_maxSegmentCount@{shm\_maxSegmentCount}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{shm\_maxSegmentCount()}{shm\_maxSegmentCount()}}
{\footnotesize\ttfamily int tipc\+::shm\+\_\+max\+Segment\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns the maximum number of shared segments allowed by the system. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00485                               \{}
\DoxyCodeLine{00486   \textcolor{keywordflow}{if} (shm\_seg < 0) \{}
\DoxyCodeLine{00487 \textcolor{preprocessor}{\#ifdef MACOSX}}
\DoxyCodeLine{00488     \textcolor{keywordtype}{size\_t} valSize = \textcolor{keyword}{sizeof}(TINT64);}
\DoxyCodeLine{00489     TINT64 val;}
\DoxyCodeLine{00490     sysctlbyname(\textcolor{stringliteral}{"{}kern.sysv.shmseg"{}}, \&val, \&valSize, NULL, 0);}
\DoxyCodeLine{00491     shm\_seg = std::min(val, (TINT64)(std::numeric\_limits<int>::max)());}
\DoxyCodeLine{00492 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00493     \textcolor{comment}{// Windows case: no such limit -\/ again, using limit against max due to Qt}}
\DoxyCodeLine{00494     shm\_seg = (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{00495 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00496   \}}
\DoxyCodeLine{00497 }
\DoxyCodeLine{00498   \textcolor{keywordflow}{return} shm\_seg;}
\DoxyCodeLine{00499 \}}

\end{DoxyCode}


Referenced by \mbox{\hyperlink{l00627}{write\+Sh\+Mem\+Buffer()}}.

\mbox{\Hypertarget{namespacetipc_a24ab553bd0dde70187d1bf3898573a35}\label{namespacetipc_a24ab553bd0dde70187d1bf3898573a35}} 
\index{tipc@{tipc}!shm\_maxSegmentSize@{shm\_maxSegmentSize}}
\index{shm\_maxSegmentSize@{shm\_maxSegmentSize}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{shm\_maxSegmentSize()}{shm\_maxSegmentSize()}}
{\footnotesize\ttfamily int tipc\+::shm\+\_\+max\+Segment\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns the maximum size of a shared memory segment allowed by the system. 


\begin{DoxyCode}{0}
\DoxyCodeLine{00463                              \{}
\DoxyCodeLine{00464   \textcolor{keywordflow}{if} (shm\_max < 0) \{}
\DoxyCodeLine{00465 \textcolor{preprocessor}{\#ifdef MACOSX}}
\DoxyCodeLine{00466     \textcolor{comment}{// Retrieve it by invoking sysctl}}
\DoxyCodeLine{00467     \textcolor{keywordtype}{size\_t} valSize = \textcolor{keyword}{sizeof}(TINT64);}
\DoxyCodeLine{00468     TINT64 val;}
\DoxyCodeLine{00469     sysctlbyname(\textcolor{stringliteral}{"{}kern.sysv.shmmax"{}}, \&val, \&valSize, NULL, 0);}
\DoxyCodeLine{00470     shm\_max = std::min(val, (TINT64)(std::numeric\_limits<int>::max)());}
\DoxyCodeLine{00471 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00472     \textcolor{comment}{// Windows case: no such limit}}
\DoxyCodeLine{00473     \textcolor{comment}{// Observe that QSharedMemory accepts only an int size -\/ so the num\_lim is}}
\DoxyCodeLine{00474     \textcolor{comment}{// against int.}}
\DoxyCodeLine{00475     shm\_max = (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{00476 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00477   \}}
\DoxyCodeLine{00478 }
\DoxyCodeLine{00479   \textcolor{keywordflow}{return} shm\_max;}
\DoxyCodeLine{00480 \}}

\end{DoxyCode}


Referenced by \mbox{\hyperlink{l00588}{create()}}.

\mbox{\Hypertarget{namespacetipc_a4860847dda94ee5bcb51374e859e076c}\label{namespacetipc_a4860847dda94ee5bcb51374e859e076c}} 
\index{tipc@{tipc}!shm\_maxSharedCount@{shm\_maxSharedCount}}
\index{shm\_maxSharedCount@{shm\_maxSharedCount}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{shm\_maxSharedCount()}{shm\_maxSharedCount()}}
{\footnotesize\ttfamily int tipc\+::shm\+\_\+max\+Shared\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{00520                              \{}
\DoxyCodeLine{00521   \textcolor{keywordflow}{if} (shm\_mni < 0) \{}
\DoxyCodeLine{00522 \textcolor{preprocessor}{\#ifdef MACOSX}}
\DoxyCodeLine{00523     \textcolor{keywordtype}{size\_t} valSize = \textcolor{keyword}{sizeof}(TINT64);}
\DoxyCodeLine{00524     TINT64 val;}
\DoxyCodeLine{00525     sysctlbyname(\textcolor{stringliteral}{"{}kern.sysv.shmmni"{}}, \&val, \&valSize, NULL, 0);}
\DoxyCodeLine{00526     shm\_mni = std::min(val, (TINT64)(std::numeric\_limits<int>::max)());}
\DoxyCodeLine{00527 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00528     shm\_mni = (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{00529 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00530   \}}
\DoxyCodeLine{00531 }
\DoxyCodeLine{00532   \textcolor{keywordflow}{return} shm\_mni;}
\DoxyCodeLine{00533 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetipc_ae0f9cce65f73f00948e1b82bb8cc185a}\label{namespacetipc_ae0f9cce65f73f00948e1b82bb8cc185a}} 
\index{tipc@{tipc}!shm\_maxSharedPages@{shm\_maxSharedPages}}
\index{shm\_maxSharedPages@{shm\_maxSharedPages}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{shm\_maxSharedPages()}{shm\_maxSharedPages()}}
{\footnotesize\ttfamily int tipc\+::shm\+\_\+max\+Shared\+Pages (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{00503                              \{}
\DoxyCodeLine{00504   \textcolor{keywordflow}{if} (shm\_all < 0) \{}
\DoxyCodeLine{00505 \textcolor{preprocessor}{\#ifdef MACOSX}}
\DoxyCodeLine{00506     \textcolor{keywordtype}{size\_t} valSize = \textcolor{keyword}{sizeof}(TINT64);}
\DoxyCodeLine{00507     TINT64 val;}
\DoxyCodeLine{00508     sysctlbyname(\textcolor{stringliteral}{"{}kern.sysv.shmall"{}}, \&val, \&valSize, NULL, 0);}
\DoxyCodeLine{00509     shm\_all = std::min(val, (TINT64)(std::numeric\_limits<int>::max)());}
\DoxyCodeLine{00510 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00511     shm\_all = (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{00512 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00513   \}}
\DoxyCodeLine{00514 }
\DoxyCodeLine{00515   \textcolor{keywordflow}{return} shm\_all;}
\DoxyCodeLine{00516 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetipc_aee1cf233a1829eb6102db2103d730bee}\label{namespacetipc_aee1cf233a1829eb6102db2103d730bee}} 
\index{tipc@{tipc}!shm\_set@{shm\_set}}
\index{shm\_set@{shm\_set}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{shm\_set()}{shm\_set()}}
{\footnotesize\ttfamily void tipc\+::shm\+\_\+set (\begin{DoxyParamCaption}\item[{int}]{shmmax,  }\item[{int}]{shmseg,  }\item[{int}]{shmall,  }\item[{int}]{shmmni }\end{DoxyParamCaption})}

Attempts to set the shared memory parameters to the system. This is only working on MAC\textquotesingle{}s SystemV shm, it\textquotesingle{}s a no-\/op on Win. This function will fail anyway if the process is not owned by an admin. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00543                                                                  \{}
\DoxyCodeLine{00544   tipc\_debug(qDebug(\textcolor{stringliteral}{"{}shmmax: \%i, shmseg: \%i, shmall: \%i, shmmni: \%i"{}}, shmmax,}
\DoxyCodeLine{00545                     shmseg, shmall, shmmni));}
\DoxyCodeLine{00546 \textcolor{preprocessor}{\#ifdef MACOSX}}
\DoxyCodeLine{00547   TINT64 val;}
\DoxyCodeLine{00548   \textcolor{keywordtype}{int} err;}
\DoxyCodeLine{00549   \textcolor{keywordflow}{if} (shmmax > 0) \{}
\DoxyCodeLine{00550     val = shmmax;}
\DoxyCodeLine{00551     err = sysctlbyname(\textcolor{stringliteral}{"{}kern.sysv.shmmax"{}}, NULL, NULL, \&val, \textcolor{keyword}{sizeof}(TINT64));}
\DoxyCodeLine{00552     \textcolor{keywordflow}{if} (!err) shm\_max = shmmax;}
\DoxyCodeLine{00553   \}}
\DoxyCodeLine{00554   \textcolor{keywordflow}{if} (shmseg > 0) \{}
\DoxyCodeLine{00555     val = shmseg;}
\DoxyCodeLine{00556     err = sysctlbyname(\textcolor{stringliteral}{"{}kern.sysv.shmseg"{}}, NULL, NULL, \&val, \textcolor{keyword}{sizeof}(TINT64));}
\DoxyCodeLine{00557     \textcolor{keywordflow}{if} (!err) shm\_seg = shmseg;}
\DoxyCodeLine{00558   \}}
\DoxyCodeLine{00559   \textcolor{keywordflow}{if} (shmall > 0) \{}
\DoxyCodeLine{00560     val = shmall;}
\DoxyCodeLine{00561     err = sysctlbyname(\textcolor{stringliteral}{"{}kern.sysv.shmall"{}}, NULL, NULL, \&val, \textcolor{keyword}{sizeof}(TINT64));}
\DoxyCodeLine{00562     \textcolor{keywordflow}{if} (!err) shm\_all = shmall;}
\DoxyCodeLine{00563   \}}
\DoxyCodeLine{00564   \textcolor{keywordflow}{if} (shmmni > 0) \{}
\DoxyCodeLine{00565     val = shmmni;}
\DoxyCodeLine{00566     err = sysctlbyname(\textcolor{stringliteral}{"{}kern.sysv.shmmni"{}}, NULL, NULL, \&val, \textcolor{keyword}{sizeof}(TINT64));}
\DoxyCodeLine{00567     \textcolor{keywordflow}{if} (!err) shm\_mni = shmmni;}
\DoxyCodeLine{00568   \}}
\DoxyCodeLine{00569 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00570 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetipc_a6804bfb80699b3a587d18284a672481a}\label{namespacetipc_a6804bfb80699b3a587d18284a672481a}} 
\index{tipc@{tipc}!startBackgroundProcess@{startBackgroundProcess}}
\index{startBackgroundProcess@{startBackgroundProcess}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{startBackgroundProcess()}{startBackgroundProcess()}}
{\footnotesize\ttfamily bool tipc\+::start\+Background\+Process (\begin{DoxyParamCaption}\item[{QString}]{cmdline }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{00263                                                  \{}
\DoxyCodeLine{00264 \textcolor{preprocessor}{\#ifdef \_WIN32}}
\DoxyCodeLine{00265   QProcess *proc = \textcolor{keyword}{new} QProcess;}
\DoxyCodeLine{00266   proc-\/>start(cmdline);}
\DoxyCodeLine{00267   \textcolor{keywordflow}{if} (proc-\/>state() == QProcess::NotRunning) \{}
\DoxyCodeLine{00268     \textcolor{keyword}{delete} proc;}
\DoxyCodeLine{00269     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00270   \}}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272   QObject::connect(proc, SIGNAL(finished(\textcolor{keywordtype}{int}, QProcess::ExitStatus)), proc,}
\DoxyCodeLine{00273                    SLOT(deleteLater()));}
\DoxyCodeLine{00274   QObject::connect(proc, SIGNAL(error(QProcess::ProcessError)), proc,}
\DoxyCodeLine{00275                    SLOT(deleteLater()));}
\DoxyCodeLine{00276   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00277 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00278   \textcolor{keywordflow}{return} QProcess::startDetached(cmdline);}
\DoxyCodeLine{00279   ;}
\DoxyCodeLine{00280 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00281 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetipc_aecf411559c63f5b9e133543db81d15a2}\label{namespacetipc_aecf411559c63f5b9e133543db81d15a2}} 
\index{tipc@{tipc}!startSlaveConnection@{startSlaveConnection}}
\index{startSlaveConnection@{startSlaveConnection}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{startSlaveConnection()}{startSlaveConnection()}}
{\footnotesize\ttfamily bool tipc\+::start\+Slave\+Connection (\begin{DoxyParamCaption}\item[{QLocal\+Socket $\ast$}]{socket,  }\item[{QString}]{srv\+Name,  }\item[{int}]{msecs = {\ttfamily -\/1},  }\item[{QString}]{cmdline = {\ttfamily QString()},  }\item[{QString}]{thread\+Name = {\ttfamily QString()} }\end{DoxyParamCaption})}

Connects the passed socket to the server with name $<$srv\+Name$>$ + $<$thread\+Name$>$. Awaits for the connection up to msecs milliseconds before returning false. If no server was found, a new slave server is started by invoking the supplied command line and connection is re-\/attempted. Returns true on success, false otherwise.

\begin{DoxyWarning}{Warning}
Please, observe that a correct slave server name should be ensured to be unique to the parent process. 
\end{DoxyWarning}

\begin{DoxyCode}{0}
\DoxyCodeLine{00368                                                     \{}
\DoxyCodeLine{00369   QTime time;}
\DoxyCodeLine{00370   time.start();}
\DoxyCodeLine{00371 }
\DoxyCodeLine{00372   \textcolor{keywordflow}{if} (msecs == -\/1) msecs = (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{00373 }
\DoxyCodeLine{00374   QString fullSrvName(srvName + threadName);}
\DoxyCodeLine{00375   socket-\/>connectToServer(fullSrvName);}
\DoxyCodeLine{00376 }
\DoxyCodeLine{00377   \textcolor{comment}{// If the socket is not connecting, the server lookup table returned that the}}
\DoxyCodeLine{00378   \textcolor{comment}{// no server with}}
\DoxyCodeLine{00379   \textcolor{comment}{// the passed name exists. This means that a server must be created.}}
\DoxyCodeLine{00380   \textcolor{keywordflow}{if} (socket-\/>state() == QLocalSocket::UnconnectedState \&\& !cmdline.isEmpty()) \{}
\DoxyCodeLine{00381     \textcolor{comment}{// Completely serialize the server start}}
\DoxyCodeLine{00382     \textcolor{keyword}{static} QMutex mutex;}
\DoxyCodeLine{00383     QMutexLocker locker(\&mutex);}
\DoxyCodeLine{00384 }
\DoxyCodeLine{00385     \textcolor{comment}{// Retry connection -\/ this is required due to the mutex}}
\DoxyCodeLine{00386     socket-\/>connectToServer(fullSrvName);}
\DoxyCodeLine{00387     \textcolor{keywordflow}{if} (socket-\/>state() != QLocalSocket::UnconnectedState) \textcolor{keywordflow}{goto} connecting;}
\DoxyCodeLine{00388 }
\DoxyCodeLine{00389     \textcolor{comment}{// Invoke the supplied command line to start the server}}
\DoxyCodeLine{00390     \textcolor{keywordflow}{if} (!\mbox{\hyperlink{namespacetipc_a2f7d4a5a27b23fa071270bcb047ccbed}{tipc::startSlaveServer}}(srvName, cmdline)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00391 }
\DoxyCodeLine{00392     \textcolor{comment}{// Reconnect to the server}}
\DoxyCodeLine{00393     socket-\/>connectToServer(fullSrvName);}
\DoxyCodeLine{00394     \textcolor{keywordflow}{if} (socket-\/>state() == QLocalSocket::UnconnectedState) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00395   \}}
\DoxyCodeLine{00396 }
\DoxyCodeLine{00397 connecting:}
\DoxyCodeLine{00398 }
\DoxyCodeLine{00399   \textcolor{comment}{// Now, the server is connecting or already connected. Wait until the socket}}
\DoxyCodeLine{00400   \textcolor{comment}{// is connected.}}
\DoxyCodeLine{00401   socket-\/>waitForConnected(msecs -\/ time.elapsed());}
\DoxyCodeLine{00402   \textcolor{keywordflow}{if} (socket-\/>state() != QLocalSocket::ConnectedState) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00403 }
\DoxyCodeLine{00404   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00405 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00298}{start\+Slave\+Server()}}.

\mbox{\Hypertarget{namespacetipc_a2f7d4a5a27b23fa071270bcb047ccbed}\label{namespacetipc_a2f7d4a5a27b23fa071270bcb047ccbed}} 
\index{tipc@{tipc}!startSlaveServer@{startSlaveServer}}
\index{startSlaveServer@{startSlaveServer}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{startSlaveServer()}{startSlaveServer()}}
{\footnotesize\ttfamily bool tipc\+::start\+Slave\+Server (\begin{DoxyParamCaption}\item[{QString}]{srv\+Name,  }\item[{QString}]{cmdline }\end{DoxyParamCaption})}

Invokes the passed command line to run a slave server. A slave server is hereby intended as a \textquotesingle{}child\textquotesingle{} server process which automatically destroys itself in case the calling application crashes. This process {\bfseries{MUST}} support one server, running in the {\bfseries{MAIN}} {\bfseries{THREAD}}, whose name is $<$srv\+Name$>$\+\_\+main. This function waits until the main server is up and ready to listen for incoming connections -\/ no timeout accepted.

\begin{DoxyWarning}{Warning}
Please, observe that a correct slave server name should be ensured to be unique to the system. 
\end{DoxyWarning}

\begin{DoxyCode}{0}
\DoxyCodeLine{00298                                                             \{}
\DoxyCodeLine{00299   \textcolor{keywordflow}{if} (!tipc::startBackgroundProcess(cmdline)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00300 }
\DoxyCodeLine{00301   QString mainSrvName(srvName + \textcolor{stringliteral}{"{}\_main"{}});}
\DoxyCodeLine{00302 }
\DoxyCodeLine{00303   \textcolor{comment}{// Establish a dummy socket connection to provide a mean for the process}}
\DoxyCodeLine{00304   \textcolor{comment}{// to tell whether the calling process exited unexpectedly.}}
\DoxyCodeLine{00305   QLocalSocket *dummySock = \textcolor{keyword}{new} QLocalSocket;}
\DoxyCodeLine{00306   dummySock-\/>connectToServer(mainSrvName);}
\DoxyCodeLine{00307 }
\DoxyCodeLine{00308   \textcolor{comment}{// Wait up to msecs until the socket is connecting. Wait a small amount of}}
\DoxyCodeLine{00309   \textcolor{comment}{// time}}
\DoxyCodeLine{00310   \textcolor{comment}{// until the server is up and listening to connection (there is no other way}}
\DoxyCodeLine{00311   \textcolor{comment}{// to tell).}}
\DoxyCodeLine{00312   \textcolor{keywordflow}{while} (dummySock-\/>state() == QLocalSocket::UnconnectedState) \{}
\DoxyCodeLine{00313 \textcolor{preprocessor}{\#ifdef \_WIN32}}
\DoxyCodeLine{00314     Sleep(10);}
\DoxyCodeLine{00315 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00316     usleep(10 << 10);  \textcolor{comment}{// 10.24 msecs}}
\DoxyCodeLine{00317 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00318 }
\DoxyCodeLine{00319     dummySock-\/>connectToServer(mainSrvName);}
\DoxyCodeLine{00320   \}}
\DoxyCodeLine{00321 }
\DoxyCodeLine{00322   dummySock-\/>waitForConnected(-\/1);}
\DoxyCodeLine{00323 }
\DoxyCodeLine{00324   \mbox{\hyperlink{classtipc_1_1_stream}{tipc::Stream}} stream(dummySock);}
\DoxyCodeLine{00325   \mbox{\hyperlink{classtipc_1_1_message}{tipc::Message}} msg;}
\DoxyCodeLine{00326 }
\DoxyCodeLine{00327   \textcolor{comment}{// Supply the 'quit if this socket connection fails' command}}
\DoxyCodeLine{00328   \textcolor{comment}{// This command ensure termination of the child process in case of some errors}}
\DoxyCodeLine{00329   \textcolor{comment}{// or ending of the program}}
\DoxyCodeLine{00330   stream << (msg << QString(\textcolor{stringliteral}{"{}\$quit\_on\_error"{}}));}
\DoxyCodeLine{00331   \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacetipc_af7c4513a3ce3661246acec7de89ab6f0}{tipc::readMessage}}(stream, msg, 3000) == QString()) \{}
\DoxyCodeLine{00332     std::cout << \textcolor{stringliteral}{"{}tipc::startSlaveServer -\/ tipc::readMessage TIMEOUT"{}}}
\DoxyCodeLine{00333               << std::endl;}
\DoxyCodeLine{00334     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00335   \}}
\DoxyCodeLine{00336 }
\DoxyCodeLine{00337   \textcolor{comment}{// The server should die if dummyDock is destroyed. This should happen when}}
\DoxyCodeLine{00338   \textcolor{comment}{// the *MAIN* thread}}
\DoxyCodeLine{00339   \textcolor{comment}{// in *this process* exits. So, if this is not the main thread, we must move}}
\DoxyCodeLine{00340   \textcolor{comment}{// the socket there.}}
\DoxyCodeLine{00341   \textcolor{keywordflow}{if} (QCoreApplication::instance() \&\&}
\DoxyCodeLine{00342       QThread::currentThread() != QCoreApplication::instance()-\/>thread())}
\DoxyCodeLine{00343     dummySock-\/>moveToThread(QCoreApplication::instance()-\/>thread());}
\DoxyCodeLine{00344 }
\DoxyCodeLine{00345   \textcolor{comment}{// If a connection error takes place, release the dummy socket.}}
\DoxyCodeLine{00346   \textcolor{comment}{// Please, observe that this QObject::connect is invoked *AFTER* the}}
\DoxyCodeLine{00347   \textcolor{comment}{// connection trials above...}}
\DoxyCodeLine{00348   QObject::connect(dummySock, SIGNAL(error(QLocalSocket::LocalSocketError)),}
\DoxyCodeLine{00349                    dummySock, SLOT(deleteLater()));}
\DoxyCodeLine{00350 }
\DoxyCodeLine{00351   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00352 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00422}{read\+Message()}}.



Referenced by \mbox{\hyperlink{l00366}{start\+Slave\+Connection()}}.

\mbox{\Hypertarget{namespacetipc_a136469c8fb1b3c40c59ab0892b388bf4}\label{namespacetipc_a136469c8fb1b3c40c59ab0892b388bf4}} 
\index{tipc@{tipc}!uniqueId@{uniqueId}}
\index{uniqueId@{uniqueId}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{uniqueId()}{uniqueId()}}
{\footnotesize\ttfamily QString tipc\+::unique\+Id (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns an inter-\/process unique id string; the returned id should be used to create QShared\+Memory objects. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00453                        \{}
\DoxyCodeLine{00454   \textcolor{keyword}{static} QAtomicInt count;}
\DoxyCodeLine{00455   count.ref();}
\DoxyCodeLine{00456   \textcolor{keywordflow}{return} QString::number(QCoreApplication::applicationPid()) + \textcolor{stringliteral}{"{}\_"{}} +}
\DoxyCodeLine{00457          QString::number((\textcolor{keywordtype}{int})count);}
\DoxyCodeLine{00458 \}}

\end{DoxyCode}


Referenced by \mbox{\hyperlink{l00627}{write\+Sh\+Mem\+Buffer()}}.

\mbox{\Hypertarget{namespacetipc_a20c43aa530b558c7dcb3149d8901bdc4}\label{namespacetipc_a20c43aa530b558c7dcb3149d8901bdc4}} 
\index{tipc@{tipc}!writeShMemBuffer@{writeShMemBuffer}}
\index{writeShMemBuffer@{writeShMemBuffer}!tipc@{tipc}}
\doxysubsubsection{\texorpdfstring{writeShMemBuffer()}{writeShMemBuffer()}}
{\footnotesize\ttfamily bool tipc\+::write\+Sh\+Mem\+Buffer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtipc_1_1_stream}{Stream}} \&}]{stream,  }\item[{\mbox{\hyperlink{classtipc_1_1_message}{Message}} \&}]{msg,  }\item[{int}]{buf\+Size,  }\item[{\mbox{\hyperlink{classtipc_1_1_sh_mem_writer}{Sh\+Mem\+Writer}} $\ast$}]{data\+Writer }\end{DoxyParamCaption})}

Writes data through a shared memory segment medium. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00628                                                      \{}
\DoxyCodeLine{00629   tipc\_debug(QTime time; time.start());}
\DoxyCodeLine{00630   tipc\_debug(qDebug(\textcolor{stringliteral}{"{}tipc::writeShMemBuffer entry"{}}));}
\DoxyCodeLine{00631 }
\DoxyCodeLine{00632   \textcolor{keyword}{static} QSemaphore sem(\mbox{\hyperlink{namespacetipc_a8de9c57a17b010d88d87c4134ef4818d}{tipc::shm\_maxSegmentCount}}());}
\DoxyCodeLine{00633   sem.acquire(1);}
\DoxyCodeLine{00634 }
\DoxyCodeLine{00635   \{}
\DoxyCodeLine{00636     \textcolor{comment}{// Create a shared memory segment, possibly of passed size}}
\DoxyCodeLine{00637     QSharedMemory shmem(\mbox{\hyperlink{namespacetipc_a136469c8fb1b3c40c59ab0892b388bf4}{tipc::uniqueId}}());}
\DoxyCodeLine{00638     \textcolor{keywordtype}{bool} ok = (\mbox{\hyperlink{namespacetipc_a69f3a9b4df074628fa5e1cba5db511ae}{tipc::create}}(shmem, bufSize) > 0);}
\DoxyCodeLine{00639     \textcolor{keywordflow}{if} (!ok) \textcolor{keywordflow}{goto} err;}
\DoxyCodeLine{00640 }
\DoxyCodeLine{00641     \textcolor{comment}{// Communicate the shared memory id and bufSize to the reader}}
\DoxyCodeLine{00642     msg << QString(\textcolor{stringliteral}{"{}shm"{}}) << shmem.key() << bufSize;}
\DoxyCodeLine{00643 }
\DoxyCodeLine{00644     \textcolor{comment}{// Fill in data until all the buffer has been sent}}
\DoxyCodeLine{00645     \textcolor{keywordtype}{int} chunkData, remainingData = bufSize;}
\DoxyCodeLine{00646     \textcolor{keywordflow}{while} (remainingData > 0) \{}
\DoxyCodeLine{00647       \textcolor{comment}{// Write to the shared memory segment}}
\DoxyCodeLine{00648       tipc\_debug(QTime xchTime; xchTime.start());}
\DoxyCodeLine{00649       shmem.lock();}
\DoxyCodeLine{00650       remainingData -\/= chunkData = dataWriter-\/>write(}
\DoxyCodeLine{00651           (\textcolor{keywordtype}{char} *)shmem.data(), std::min(shmem.size(), remainingData));}
\DoxyCodeLine{00652       shmem.unlock();}
\DoxyCodeLine{00653       tipc\_debug(qDebug() << \textcolor{stringliteral}{"{}exchange time:"{}} << xchTime.elapsed());}
\DoxyCodeLine{00654 }
\DoxyCodeLine{00655       stream << (msg << QString(\textcolor{stringliteral}{"{}chk"{}}) << chunkData);}
\DoxyCodeLine{00656 }
\DoxyCodeLine{00657       \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacetipc_af7c4513a3ce3661246acec7de89ab6f0}{tipc::readMessage}}(stream, msg) != \textcolor{stringliteral}{"{}ok"{}}) \textcolor{keywordflow}{goto} err;}
\DoxyCodeLine{00658 }
\DoxyCodeLine{00659       msg.clear();}
\DoxyCodeLine{00660     \}}
\DoxyCodeLine{00661   \}}
\DoxyCodeLine{00662 }
\DoxyCodeLine{00663   sem.release(1);}
\DoxyCodeLine{00664   tipc\_debug(qDebug(\textcolor{stringliteral}{"{}tipc::writeShMemBuffer exit"{}}));}
\DoxyCodeLine{00665   tipc\_debug(qDebug() << \textcolor{stringliteral}{"{}tipc::writeShMemBuffer time:"{}} << time.elapsed());}
\DoxyCodeLine{00666   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00667 }
\DoxyCodeLine{00668 err:}
\DoxyCodeLine{00669 }
\DoxyCodeLine{00670   tipc\_debug(qDebug(\textcolor{stringliteral}{"{}tipc::writeShMemBuffer exit (error)"{}}));}
\DoxyCodeLine{00671 }
\DoxyCodeLine{00672   msg.clear();}
\DoxyCodeLine{00673   sem.release(1);}
\DoxyCodeLine{00674   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00675 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00588}{create()}}, \mbox{\hyperlink{l00422}{read\+Message()}}, \mbox{\hyperlink{l00485}{shm\+\_\+max\+Segment\+Count()}}, and \mbox{\hyperlink{l00453}{unique\+Id()}}.

