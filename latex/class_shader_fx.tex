\hypertarget{class_shader_fx}{}\doxysection{Shader\+Fx Class Reference}
\label{class_shader_fx}\index{ShaderFx@{ShaderFx}}
Inheritance diagram for Shader\+Fx\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6.000000cm]{class_shader_fx}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_shader_fx_afbe1cf2fb6501d599ec8e54a4b4f1474}{Shader\+Fx}} (const \mbox{\hyperlink{class_shader_interface}{Shader\+Interface}} $\ast$shader\+Interface)
\item 
void \mbox{\hyperlink{class_shader_fx_a75e7be102ea4268100835c37db6612be}{initialize}} ()
\item 
void \mbox{\hyperlink{class_shader_fx_a03bd073b9f383c7c9dc336c27757acb0}{get\+Param\+UIs}} (\mbox{\hyperlink{class_t_param_u_i_concept}{TParam\+UIConcept}} $\ast$\&params, int \&length) override
\item 
bool \mbox{\hyperlink{class_shader_fx_a753641aa0f935846a262fc050d608edd}{do\+Get\+BBox}} (double frame, \mbox{\hyperlink{class_t_rect_t}{TRectD}} \&b\+Box, const \mbox{\hyperlink{class_t_render_settings}{TRender\+Settings}} \&info) override
\item 
bool \mbox{\hyperlink{class_shader_fx_a69b3ca5a317e19962f16d9b43e58f6b3}{can\+Handle}} (const \mbox{\hyperlink{class_t_render_settings}{TRender\+Settings}} \&info, double frame) override
\item 
void \mbox{\hyperlink{class_shader_fx_ab214f59f210598fc184655909ea1d42a}{do\+Dry\+Compute}} (\mbox{\hyperlink{class_t_rect_t}{TRectD}} \&rect, double frame, const \mbox{\hyperlink{class_t_render_settings}{TRender\+Settings}} \&ri) override
\item 
void \mbox{\hyperlink{class_shader_fx_aca08c8818bee7c66fb7935cda377d362}{do\+Compute}} (\mbox{\hyperlink{class_t_tile}{TTile}} \&tile, double frame, const \mbox{\hyperlink{class_t_render_settings}{TRender\+Settings}} \&ri) override
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_shader_fx_aa6b1f40489fa0930691dbb8175b8e849}\label{class_shader_fx_aa6b1f40489fa0930691dbb8175b8e849}} 
\index{ShaderFx@{ShaderFx}!ShaderFx@{ShaderFx}}
\index{ShaderFx@{ShaderFx}!ShaderFx@{ShaderFx}}
\doxysubsubsection{\texorpdfstring{ShaderFx()}{ShaderFx()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Shader\+Fx\+::\+Shader\+Fx (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00173              : m\_shaderInterface() \{}
\DoxyCodeLine{00174     assert(\textcolor{keyword}{false});}
\DoxyCodeLine{00175   \}  \textcolor{comment}{// Necessary due to TPersist inheritance, but must NOT be used}}

\end{DoxyCode}
\mbox{\Hypertarget{class_shader_fx_afbe1cf2fb6501d599ec8e54a4b4f1474}\label{class_shader_fx_afbe1cf2fb6501d599ec8e54a4b4f1474}} 
\index{ShaderFx@{ShaderFx}!ShaderFx@{ShaderFx}}
\index{ShaderFx@{ShaderFx}!ShaderFx@{ShaderFx}}
\doxysubsubsection{\texorpdfstring{ShaderFx()}{ShaderFx()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Shader\+Fx\+::\+Shader\+Fx (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_shader_interface}{Shader\+Interface}} $\ast$}]{shader\+Interface }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00177       : m\_shaderInterface(shaderInterface) \{}
\DoxyCodeLine{00178     initialize();}
\DoxyCodeLine{00179   \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_shader_fx_a69b3ca5a317e19962f16d9b43e58f6b3}\label{class_shader_fx_a69b3ca5a317e19962f16d9b43e58f6b3}} 
\index{ShaderFx@{ShaderFx}!canHandle@{canHandle}}
\index{canHandle@{canHandle}!ShaderFx@{ShaderFx}}
\doxysubsubsection{\texorpdfstring{canHandle()}{canHandle()}}
{\footnotesize\ttfamily bool Shader\+Fx\+::can\+Handle (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_t_render_settings}{TRender\+Settings}} \&}]{info,  }\item[{double}]{frame }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Implements \mbox{\hyperlink{class_t_raster_fx}{TRaster\+Fx}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00681                                                                   \{}
\DoxyCodeLine{00682   \textcolor{keywordflow}{return} (m\_shaderInterface-\/>hwtType() == ShaderInterface::ANY)}
\DoxyCodeLine{00683              ? true}
\DoxyCodeLine{00684              : isAlmostIsotropic(info.m\_affine);}
\DoxyCodeLine{00685 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_shader_fx_aca08c8818bee7c66fb7935cda377d362}\label{class_shader_fx_aca08c8818bee7c66fb7935cda377d362}} 
\index{ShaderFx@{ShaderFx}!doCompute@{doCompute}}
\index{doCompute@{doCompute}!ShaderFx@{ShaderFx}}
\doxysubsubsection{\texorpdfstring{doCompute()}{doCompute()}}
{\footnotesize\ttfamily void Shader\+Fx\+::do\+Compute (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_t_tile}{TTile}} \&}]{tile,  }\item[{double}]{frame,  }\item[{const \mbox{\hyperlink{class_t_render_settings}{TRender\+Settings}} \&}]{ri }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Implements \mbox{\hyperlink{class_t_raster_fx}{TRaster\+Fx}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00953                                                       \{}
\DoxyCodeLine{00954   \textcolor{keyword}{struct }locals \{}
\DoxyCodeLine{00955     \textcolor{keyword}{struct }TexturesStorage \{}
\DoxyCodeLine{00956       \mbox{\hyperlink{class_shading_context}{ShadingContext}} \&m\_ctx;}
\DoxyCodeLine{00957       std::vector<GLuint> m\_texIds;}
\DoxyCodeLine{00958 }
\DoxyCodeLine{00959       TexturesStorage(\mbox{\hyperlink{class_shading_context}{ShadingContext}} \&ctx, \textcolor{keywordtype}{int} pCount) : m\_ctx(ctx) \{}
\DoxyCodeLine{00960         m\_texIds.reserve(pCount);}
\DoxyCodeLine{00961       \}}
\DoxyCodeLine{00962 }
\DoxyCodeLine{00963       \string~TexturesStorage() \{}
\DoxyCodeLine{00964         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&texId : m\_texIds) \{}
\DoxyCodeLine{00965           m\_ctx.\mbox{\hyperlink{class_shading_context_ac09702f0fb8b2a9857f1e385426b8fd2}{unloadTexture}}(texId);}
\DoxyCodeLine{00966         \}}
\DoxyCodeLine{00967       \}}
\DoxyCodeLine{00968 }
\DoxyCodeLine{00969       \textcolor{keywordtype}{void} load(\textcolor{keyword}{const} \mbox{\hyperlink{class_t_smart_pointer_t}{TRasterP}} \&ras, GLuint texUnit) \{}
\DoxyCodeLine{00970         \textcolor{keywordflow}{if} (ras) m\_texIds.push\_back(m\_ctx.\mbox{\hyperlink{class_shading_context_a88ccfeba76ac4726ceae0d58dd3a6db4}{loadTexture}}(ras, texUnit));}
\DoxyCodeLine{00971       \}}
\DoxyCodeLine{00972     \};}
\DoxyCodeLine{00973 }
\DoxyCodeLine{00974     \textcolor{keyword}{inline} \textcolor{keyword}{static} QOpenGLFramebufferObjectFormat makeFormat(\textcolor{keywordtype}{int} bpp) \{}
\DoxyCodeLine{00975       QOpenGLFramebufferObjectFormat fmt;}
\DoxyCodeLine{00976       \textcolor{keywordflow}{if} (bpp == 64) fmt.setInternalTextureFormat(GL\_RGBA16);}
\DoxyCodeLine{00977       \textcolor{keywordflow}{return} fmt;}
\DoxyCodeLine{00978     \}}
\DoxyCodeLine{00979 }
\DoxyCodeLine{00980     \textcolor{keyword}{inline} \textcolor{keyword}{static} \textcolor{keywordtype}{void} touchOutputSize(\mbox{\hyperlink{class_shading_context}{ShadingContext}} \&context,}
\DoxyCodeLine{00981                                        \textcolor{keyword}{const} \mbox{\hyperlink{class_t_dimension_t}{TDimension}} \&size, \textcolor{keywordtype}{int} bpp) \{}
\DoxyCodeLine{00982       \textcolor{keyword}{const} QOpenGLFramebufferObjectFormat \&fmt = makeFormat(bpp);}
\DoxyCodeLine{00983 }
\DoxyCodeLine{00984       \textcolor{keyword}{const} \mbox{\hyperlink{class_t_dimension_t}{TDimension}} \&currentSize                    = context.size();}
\DoxyCodeLine{00985       \textcolor{keyword}{const} QOpenGLFramebufferObjectFormat \&currentFmt = context.format();}
\DoxyCodeLine{00986 }
\DoxyCodeLine{00987       \textcolor{keywordflow}{if} (currentSize.lx < size.lx || currentSize.ly < size.ly ||}
\DoxyCodeLine{00988           currentFmt != fmt)}
\DoxyCodeLine{00989         context.\mbox{\hyperlink{class_shading_context_a4416f47c0257a17b094fd7c0611309ff}{resize}}(std::max(size.lx, currentSize.lx),}
\DoxyCodeLine{00990                        std::max(size.ly, currentSize.ly), fmt);}
\DoxyCodeLine{00991     \}}
\DoxyCodeLine{00992   \};  \textcolor{comment}{// locals}}
\DoxyCodeLine{00993 }
\DoxyCodeLine{00994   \mbox{\hyperlink{class_shading_context_manager}{ShadingContextManager}} *manager = ShadingContextManager::instance();}
\DoxyCodeLine{00995   \textcolor{keywordflow}{if} (manager-\/>touchSupport() != ShadingContext::OK) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00996 }
\DoxyCodeLine{00997   QMutexLocker mLocker(}
\DoxyCodeLine{00998       manager-\/>mutex());  \textcolor{comment}{// As GPU access can be considered sequential anyway,}}
\DoxyCodeLine{00999                           \textcolor{comment}{// lock the full-\/scale mutex}}
\DoxyCodeLine{01000   std::shared\_ptr<ShadingContext> shadingContextPtr(}
\DoxyCodeLine{01001       \textcolor{keyword}{new} \mbox{\hyperlink{class_shading_context}{ShadingContext}}(manager-\/>getSurface()));}
\DoxyCodeLine{01002   \mbox{\hyperlink{class_shading_context}{ShadingContext}} \&context = *shadingContextPtr.get();}
\DoxyCodeLine{01003   \textcolor{comment}{// ShadingContext\& context = manager-\/>shadingContext();}}
\DoxyCodeLine{01004 }
\DoxyCodeLine{01005   \textcolor{keywordtype}{int} pCount = getInputPortCount();}
\DoxyCodeLine{01006 }
\DoxyCodeLine{01007   \textcolor{keyword}{const} \mbox{\hyperlink{class_t_rect_t}{TRectD}} \&tileRect = ::tileRect(tile);}
\DoxyCodeLine{01008 }
\DoxyCodeLine{01009   std::vector<TRectD> inputRects(pCount);}
\DoxyCodeLine{01010   std::vector<TAffine> inputAffines(pCount);}
\DoxyCodeLine{01011 }
\DoxyCodeLine{01012   \textcolor{comment}{// Calculate input tiles}}
\DoxyCodeLine{01013   ::ContextLocker cLocker(context);}
\DoxyCodeLine{01014 }
\DoxyCodeLine{01015   std::unique\_ptr<TTile[]> inTiles(}
\DoxyCodeLine{01016       \textcolor{keyword}{new} \mbox{\hyperlink{class_t_tile}{TTile}}[pCount]);  \textcolor{comment}{// NOTE: Input tiles must be STORED -\/ they cannot}}
\DoxyCodeLine{01017   \textcolor{comment}{// be passed immediately to OpenGL, since *other shader}}
\DoxyCodeLine{01018   \textcolor{keywordflow}{if} (pCount > 0)  \textcolor{comment}{// fxs*, with the very same host context, could lie}}
\DoxyCodeLine{01019   \{                \textcolor{comment}{// inside this fx's input branches...}}
\DoxyCodeLine{01020     getInputData(tileRect, frame, info, inputRects, inputAffines, context);}
\DoxyCodeLine{01021 }
\DoxyCodeLine{01022     \textcolor{comment}{// Release context and mutex}}
\DoxyCodeLine{01023     cLocker.unlock();}
\DoxyCodeLine{01024     mLocker.unlock();}
\DoxyCodeLine{01025 }
\DoxyCodeLine{01026     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p = 0; p != pCount; ++p) \{}
\DoxyCodeLine{01027       \mbox{\hyperlink{class_t_raster_fx_port}{TRasterFxPort}} \&port = m\_inputPorts[p];}
\DoxyCodeLine{01028       \textcolor{keywordflow}{if} (port.isConnected()) \{}
\DoxyCodeLine{01029         \textcolor{comment}{// Compute input tile}}
\DoxyCodeLine{01030         \mbox{\hyperlink{class_t_rect_t}{TRectD}} \&inRect = inputRects[p];}
\DoxyCodeLine{01031         \textcolor{keywordflow}{if} (inRect.getLx() > 0.0 \&\& inRect.getLy() > 0.0) \{}
\DoxyCodeLine{01032           ::ceilRect(inRect);}
\DoxyCodeLine{01033 }
\DoxyCodeLine{01034           \mbox{\hyperlink{class_t_render_settings}{TRenderSettings}} inputInfo(info);}
\DoxyCodeLine{01035           inputInfo.m\_affine = inputAffines[p];}
\DoxyCodeLine{01036 }
\DoxyCodeLine{01037 \textcolor{preprocessor}{\#ifdef TRANSFORM\_FEEDBACK\_COUT}}
\DoxyCodeLine{01038           \textcolor{keyword}{const} \mbox{\hyperlink{class_t_affine}{TAffine}} \&inAff = inputAffines[p];}
\DoxyCodeLine{01039           std::cout << \textcolor{stringliteral}{"{}inRect "{}} << p << \textcolor{stringliteral}{"{}: "{}} << inRect.\mbox{\hyperlink{class_t_rect_t_ac008cbc625f50d8b3c180c8eb2594cdb}{x0}} << \textcolor{stringliteral}{"{} "{}} << inRect.y0}
\DoxyCodeLine{01040                     << \textcolor{stringliteral}{"{} "{}} << inRect.x1 << \textcolor{stringliteral}{"{} "{}} << inRect.y1 << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{01041           std::cout << \textcolor{stringliteral}{"{}inAff  "{}} << p << \textcolor{stringliteral}{"{}: "{}} << inAff.a11 << \textcolor{stringliteral}{"{} "{}} << inAff.a12}
\DoxyCodeLine{01042                     << \textcolor{stringliteral}{"{} "{}} << inAff.a13 << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{01043           std::cout << \textcolor{stringliteral}{"{}          "{}} << inAff.a21 << \textcolor{stringliteral}{"{} "{}} << inAff.a22 << \textcolor{stringliteral}{"{} "{}}}
\DoxyCodeLine{01044                     << inAff.a23 << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{01045                     << std::endl;}
\DoxyCodeLine{01046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01047 }
\DoxyCodeLine{01048           port-\/>allocateAndCompute(}
\DoxyCodeLine{01049               inTiles[p], inRect.getP00(),}
\DoxyCodeLine{01050               \mbox{\hyperlink{class_t_dimension_t}{TDimension}}(tround(inRect.getLx()), tround(inRect.getLy())),}
\DoxyCodeLine{01051               tile.getRaster(), frame, inputInfo);}
\DoxyCodeLine{01052         \}}
\DoxyCodeLine{01053       \}}
\DoxyCodeLine{01054     \}}
\DoxyCodeLine{01055 }
\DoxyCodeLine{01056     \textcolor{comment}{// Load input tiles on the GPU as textures}}
\DoxyCodeLine{01057     mLocker.relock();}
\DoxyCodeLine{01058     cLocker.relock();}
\DoxyCodeLine{01059 }
\DoxyCodeLine{01060     \textcolor{comment}{// Input tiles are NOT supplied to OpenGL here -\/ but rather just before}}
\DoxyCodeLine{01061     \textcolor{comment}{// drawing.}}
\DoxyCodeLine{01062     \textcolor{comment}{// It's probably because a uniform integer variable must have already been}}
\DoxyCodeLine{01063     \textcolor{comment}{// bound}}
\DoxyCodeLine{01064     \textcolor{comment}{// to prepare the associated sampler variable in the linkes program...}}
\DoxyCodeLine{01065   \}}
\DoxyCodeLine{01066 }
\DoxyCodeLine{01067   \textcolor{comment}{// Perform the actual fragment shading}}
\DoxyCodeLine{01068   \{}
\DoxyCodeLine{01069     locals::touchOutputSize(context, tile.getRaster()-\/>getSize(), info.m\_bpp);}
\DoxyCodeLine{01070 }
\DoxyCodeLine{01071     QOpenGLShaderProgram *program =}
\DoxyCodeLine{01072         touchShaderProgram(m\_shaderInterface-\/>mainShader(), context);}
\DoxyCodeLine{01073     \{}
\DoxyCodeLine{01074       ProgramBinder binder(program);}
\DoxyCodeLine{01075 }
\DoxyCodeLine{01076       \textcolor{comment}{// Bind parameters and textures}}
\DoxyCodeLine{01077       bindParameters(program, frame);}
\DoxyCodeLine{01078       bindWorldTransform(program, \mbox{\hyperlink{class_t_translation}{TTranslation}}(-\/tile.m\_pos) * info.m\_affine);}
\DoxyCodeLine{01079 }
\DoxyCodeLine{01080       \textcolor{comment}{// Setup input data, if any}}
\DoxyCodeLine{01081       locals::TexturesStorage texStorage(context, pCount);}
\DoxyCodeLine{01082 }
\DoxyCodeLine{01083       \textcolor{keywordflow}{if} (pCount > 0) \{}
\DoxyCodeLine{01084         std::vector<GLint> inputs(pCount);}
\DoxyCodeLine{01085         std::vector<QMatrix3x3> screenToInput(pCount);}
\DoxyCodeLine{01086         std::vector<QMatrix3x3> inputToScreen(pCount);}
\DoxyCodeLine{01087 }
\DoxyCodeLine{01088         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p = 0; p != pCount; ++p) \{}
\DoxyCodeLine{01089           \mbox{\hyperlink{class_t_affine}{TAffine}} iToS(}
\DoxyCodeLine{01090               \mbox{\hyperlink{class_t_translation}{TTranslation}}(-\/tile.m\_pos) *             \textcolor{comment}{// Output to Screen}}
\DoxyCodeLine{01091               info.m\_affine *                         \textcolor{comment}{// World to Output}}
\DoxyCodeLine{01092               inputAffines[p].inv() *                 \textcolor{comment}{// Input to World}}
\DoxyCodeLine{01093               \mbox{\hyperlink{class_t_translation}{TTranslation}}(inputRects[p].getP00()) *  \textcolor{comment}{// Texture to Input}}
\DoxyCodeLine{01094               \mbox{\hyperlink{class_t_scale}{TScale}}(inputRects[p].getLx(), inputRects[p].getLy()));  \textcolor{comment}{//}}
\DoxyCodeLine{01095 }
\DoxyCodeLine{01096           \mbox{\hyperlink{class_t_affine}{TAffine}} sToI(iToS.inv());}
\DoxyCodeLine{01097 }
\DoxyCodeLine{01098 \textcolor{preprocessor}{\#if QT\_VERSION >= 0x050500}}
\DoxyCodeLine{01099           \textcolor{keywordtype}{float} qiToS[9] = \{\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(iToS.a11),}
\DoxyCodeLine{01100                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(iToS.a12),}
\DoxyCodeLine{01101                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(iToS.a13),}
\DoxyCodeLine{01102                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(iToS.a21),}
\DoxyCodeLine{01103                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(iToS.a22),}
\DoxyCodeLine{01104                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(iToS.a23),}
\DoxyCodeLine{01105                             0.0f,}
\DoxyCodeLine{01106                             0.0f,}
\DoxyCodeLine{01107                             1.0f\};}
\DoxyCodeLine{01108           \textcolor{keywordtype}{float} qsToI[9] = \{\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(sToI.a11),}
\DoxyCodeLine{01109                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(sToI.a12),}
\DoxyCodeLine{01110                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(sToI.a13),}
\DoxyCodeLine{01111                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(sToI.a21),}
\DoxyCodeLine{01112                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(sToI.a22),}
\DoxyCodeLine{01113                             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(sToI.a23),}
\DoxyCodeLine{01114                             0.0f,}
\DoxyCodeLine{01115                             0.0f,}
\DoxyCodeLine{01116                             1.0f\};}
\DoxyCodeLine{01117 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01118           qreal qiToS[9] = \{iToS.a11, iToS.a12, iToS.a13, iToS.a21, iToS.a22,}
\DoxyCodeLine{01119                             iToS.a23, 0.0,      0.0,      1.0\};}
\DoxyCodeLine{01120 }
\DoxyCodeLine{01121           qreal qsToI[9] = \{sToI.a11, sToI.a12, sToI.a13, sToI.a21, sToI.a22,}
\DoxyCodeLine{01122                             sToI.a23, 0.0,      0.0,      1.0\};}
\DoxyCodeLine{01123 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01124           inputs[p] = p, screenToInput[p] = QMatrix3x3(qsToI),}
\DoxyCodeLine{01125           inputToScreen[p] = QMatrix3x3(qiToS);}
\DoxyCodeLine{01126         \}}
\DoxyCodeLine{01127 }
\DoxyCodeLine{01128         program-\/>setUniformValueArray(\textcolor{stringliteral}{"{}inputImage"{}}, \&inputs[0], pCount);}
\DoxyCodeLine{01129         program-\/>setUniformValueArray(\textcolor{stringliteral}{"{}outputToInput"{}}, \&screenToInput[0],}
\DoxyCodeLine{01130                                       pCount);}
\DoxyCodeLine{01131         program-\/>setUniformValueArray(\textcolor{stringliteral}{"{}inputToOutput"{}}, \&inputToScreen[0],}
\DoxyCodeLine{01132                                       pCount);}
\DoxyCodeLine{01133 }
\DoxyCodeLine{01134         \textcolor{comment}{// Load textures}}
\DoxyCodeLine{01135         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p = 0; p != pCount; ++p)}
\DoxyCodeLine{01136           texStorage.load(inTiles[p].getRaster(), p);}
\DoxyCodeLine{01137       \}}
\DoxyCodeLine{01138 }
\DoxyCodeLine{01139 \textcolor{preprocessor}{\#ifdef DIAGNOSTICS}}
\DoxyCodeLine{01140       DIAGNOSTICS\_TIMER(\textcolor{stringliteral}{"{}Shader Overall Times | "{}} +}
\DoxyCodeLine{01141                         m\_shaderInterface-\/>m\_mainShader.\mbox{\hyperlink{class_shader_interface_1_1_shader_data_a59542536d3858d4776b8f903dea77371}{m\_name}});}
\DoxyCodeLine{01142 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01143 }
\DoxyCodeLine{01144       context.\mbox{\hyperlink{class_shading_context_a91ecdbf1004866713dc0b13f0db02f94}{draw}}(tile.getRaster());}
\DoxyCodeLine{01145     \}}
\DoxyCodeLine{01146   \}}
\DoxyCodeLine{01147 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_shader_fx_ab214f59f210598fc184655909ea1d42a}\label{class_shader_fx_ab214f59f210598fc184655909ea1d42a}} 
\index{ShaderFx@{ShaderFx}!doDryCompute@{doDryCompute}}
\index{doDryCompute@{doDryCompute}!ShaderFx@{ShaderFx}}
\doxysubsubsection{\texorpdfstring{doDryCompute()}{doDryCompute()}}
{\footnotesize\ttfamily void Shader\+Fx\+::do\+Dry\+Compute (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_t_rect_t}{TRectD}} \&}]{rect,  }\item[{double}]{frame,  }\item[{const \mbox{\hyperlink{class_t_render_settings}{TRender\+Settings}} \&}]{info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Declares the computation scheme of this fx for rendering optimization purposes. This is an important function of the Toonz rendering API, and should be reimplemented with the necessary care. The Toonz rendering process makes use of this function to enact most of the optimization steps about the fx computation, in particular fx caching. A correct implementation of this method should follow these rules\+:  The invocation of child node computations should be faithfully reproduced.  TRaster\+Fx\+::compute and TRaster\+Fx\+::allocate\+And\+Compute calls have to be translated to TRaster\+Fx\+::dry\+Compute calls.  This fx is intended for precomputation stage, so the hard rendering code should be skipped here. By default, this method raises a dry\+Compute call to each input port in increasing order, using the TRaster\+Fx\+::transform method to identify the tiles to be passed on input precomputation. 

Reimplemented from \mbox{\hyperlink{class_t_raster_fx_a47ec31d2d4c3a066cd6744fb8c80edf2}{TRaster\+Fx}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{01152                                                          \{}
\DoxyCodeLine{01153   \mbox{\hyperlink{class_shading_context_manager}{ShadingContextManager}} *manager = ShadingContextManager::instance();}
\DoxyCodeLine{01154   \textcolor{keywordflow}{if} (manager-\/>touchSupport() != ShadingContext::OK) \textcolor{keywordflow}{return};}
\DoxyCodeLine{01155 }
\DoxyCodeLine{01156   QMutexLocker mLocker(manager-\/>mutex());}
\DoxyCodeLine{01157 }
\DoxyCodeLine{01158   \textcolor{comment}{// ShadingContext\& context = manager-\/>shadingContext();}}
\DoxyCodeLine{01159   std::shared\_ptr<ShadingContext> shadingContextPtr(}
\DoxyCodeLine{01160       \textcolor{keyword}{new} \mbox{\hyperlink{class_shading_context}{ShadingContext}}(manager-\/>getSurface()));}
\DoxyCodeLine{01161   \mbox{\hyperlink{class_shading_context}{ShadingContext}} \&context = *shadingContextPtr.get();}
\DoxyCodeLine{01162 }
\DoxyCodeLine{01163   \textcolor{keywordtype}{int} pCount = getInputPortCount();}
\DoxyCodeLine{01164   \textcolor{keywordflow}{if} (pCount > 0) \{}
\DoxyCodeLine{01165     ::ContextLocker cLocker(context);}
\DoxyCodeLine{01166 }
\DoxyCodeLine{01167     std::vector<TRectD> inputRects(pCount);}
\DoxyCodeLine{01168     std::vector<TAffine> inputAffines(pCount);}
\DoxyCodeLine{01169 }
\DoxyCodeLine{01170     getInputData(rect, frame, info, inputRects, inputAffines, context);}
\DoxyCodeLine{01171 }
\DoxyCodeLine{01172     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p = 0; p != pCount; ++p) \{}
\DoxyCodeLine{01173       \mbox{\hyperlink{class_t_raster_fx_port}{TRasterFxPort}} \&port = m\_inputPorts[p];}
\DoxyCodeLine{01174       \textcolor{keywordflow}{if} (port.isConnected()) \{}
\DoxyCodeLine{01175         \mbox{\hyperlink{class_t_rect_t}{TRectD}} \&inRect = inputRects[p];}
\DoxyCodeLine{01176         \textcolor{keywordflow}{if} (inRect.getLx() > 0.0 \&\& inRect.getLy() > 0.0) \{}
\DoxyCodeLine{01177           ::ceilRect(inRect);}
\DoxyCodeLine{01178 }
\DoxyCodeLine{01179           \mbox{\hyperlink{class_t_render_settings}{TRenderSettings}} inputInfo(info);}
\DoxyCodeLine{01180           inputInfo.m\_affine = inputAffines[p];}
\DoxyCodeLine{01181 }
\DoxyCodeLine{01182           cLocker.unlock();}
\DoxyCodeLine{01183           mLocker.unlock();}
\DoxyCodeLine{01184 }
\DoxyCodeLine{01185           port-\/>dryCompute(inRect, frame, inputInfo);}
\DoxyCodeLine{01186 }
\DoxyCodeLine{01187           mLocker.relock();}
\DoxyCodeLine{01188           cLocker.relock();}
\DoxyCodeLine{01189         \}}
\DoxyCodeLine{01190       \}}
\DoxyCodeLine{01191     \}}
\DoxyCodeLine{01192   \}}
\DoxyCodeLine{01193 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00097}{TRender\+Settings\+::m\+\_\+affine}}.

\mbox{\Hypertarget{class_shader_fx_a753641aa0f935846a262fc050d608edd}\label{class_shader_fx_a753641aa0f935846a262fc050d608edd}} 
\index{ShaderFx@{ShaderFx}!doGetBBox@{doGetBBox}}
\index{doGetBBox@{doGetBBox}!ShaderFx@{ShaderFx}}
\doxysubsubsection{\texorpdfstring{doGetBBox()}{doGetBBox()}}
{\footnotesize\ttfamily bool Shader\+Fx\+::do\+Get\+BBox (\begin{DoxyParamCaption}\item[{double}]{frame,  }\item[{\mbox{\hyperlink{class_t_rect_t}{TRectD}} \&}]{b\+Box,  }\item[{const \mbox{\hyperlink{class_t_render_settings}{TRender\+Settings}} \&}]{info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Implements \mbox{\hyperlink{class_t_raster_fx}{TRaster\+Fx}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00598                                                       \{}
\DoxyCodeLine{00599   \textcolor{keyword}{static} const ::RectF infiniteRectF(-\/(std::numeric\_limits<GLfloat>::max)(),}
\DoxyCodeLine{00600                                      -\/(std::numeric\_limits<GLfloat>::max)(),}
\DoxyCodeLine{00601                                      (std::numeric\_limits<GLfloat>::max)(),}
\DoxyCodeLine{00602                                      (std::numeric\_limits<GLfloat>::max)());}
\DoxyCodeLine{00603 }
\DoxyCodeLine{00604   bbox = TConsts::infiniteRectD;}
\DoxyCodeLine{00605 }
\DoxyCodeLine{00606   \textcolor{keyword}{const} \mbox{\hyperlink{class_shader_interface_1_1_shader_data}{ShaderInterface::ShaderData}} \&sd = m\_shaderInterface-\/>bboxShader();}
\DoxyCodeLine{00607   \textcolor{keywordflow}{if} (!sd.isValid()) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00608 }
\DoxyCodeLine{00609   \mbox{\hyperlink{class_shading_context_manager}{ShadingContextManager}} *manager = ShadingContextManager::instance();}
\DoxyCodeLine{00610   \textcolor{keywordflow}{if} (manager-\/>touchSupport() != ShadingContext::OK) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00611 }
\DoxyCodeLine{00612   \textcolor{comment}{// Remember: info.m\_affine MUST NOT BE CONSIDERED in doGetBBox's}}
\DoxyCodeLine{00613   \textcolor{comment}{// implementation}}
\DoxyCodeLine{00614   ::RectF bboxF(infiniteRectF);}
\DoxyCodeLine{00615 }
\DoxyCodeLine{00616   QMutexLocker mLocker(manager-\/>mutex());}
\DoxyCodeLine{00617 }
\DoxyCodeLine{00618   \textcolor{comment}{// ShadingContext\& context = manager-\/>shadingContext();}}
\DoxyCodeLine{00619   std::shared\_ptr<ShadingContext> shadingContextPtr(}
\DoxyCodeLine{00620       \textcolor{keyword}{new} \mbox{\hyperlink{class_shading_context}{ShadingContext}}(manager-\/>getSurface()));}
\DoxyCodeLine{00621   \mbox{\hyperlink{class_shading_context}{ShadingContext}} \&context = *shadingContextPtr.get();}
\DoxyCodeLine{00622 }
\DoxyCodeLine{00623   ::ContextLocker cLocker(context);}
\DoxyCodeLine{00624 }
\DoxyCodeLine{00625   \textcolor{comment}{// Build the varyings data}}
\DoxyCodeLine{00626   QOpenGLShaderProgram *prog = 0;}
\DoxyCodeLine{00627   \{}
\DoxyCodeLine{00628     \textcolor{keyword}{const} GLchar *varyingNames[] = \{\textcolor{stringliteral}{"{}outputBBox"{}}\};}
\DoxyCodeLine{00629     prog = touchShaderProgram(sd, context, 1, \&varyingNames[0]);}
\DoxyCodeLine{00630   \}}
\DoxyCodeLine{00631 }
\DoxyCodeLine{00632   \textcolor{keywordtype}{int} pCount = getInputPortCount();}
\DoxyCodeLine{00633 }
\DoxyCodeLine{00634   std::vector<RectF> inputBBoxes(pCount, ::RectF(\mbox{\hyperlink{class_t_rect_t}{TRectD}}()));}
\DoxyCodeLine{00635 }
\DoxyCodeLine{00636   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p = 0; p != pCount; ++p) \{}
\DoxyCodeLine{00637     \mbox{\hyperlink{class_t_raster_fx_port}{TRasterFxPort}} \&port = m\_inputPorts[p];}
\DoxyCodeLine{00638     \textcolor{keywordflow}{if} (port.isConnected()) \{}
\DoxyCodeLine{00639       \mbox{\hyperlink{class_t_rect_t}{TRectD}} inputBBox;}
\DoxyCodeLine{00640 }
\DoxyCodeLine{00641       cLocker.unlock();}
\DoxyCodeLine{00642       mLocker.unlock();}
\DoxyCodeLine{00643 }
\DoxyCodeLine{00644       \textcolor{keywordflow}{if} (port-\/>doGetBBox(frame, inputBBox, info))}
\DoxyCodeLine{00645         inputBBoxes[p] = (inputBBox == TConsts::infiniteRectD)}
\DoxyCodeLine{00646                              ? infiniteRectF}
\DoxyCodeLine{00647                              : ::RectF(inputBBox);}
\DoxyCodeLine{00648 }
\DoxyCodeLine{00649       mLocker.relock();}
\DoxyCodeLine{00650       cLocker.relock();}
\DoxyCodeLine{00651     \}}
\DoxyCodeLine{00652   \}}
\DoxyCodeLine{00653 }
\DoxyCodeLine{00654   \{}
\DoxyCodeLine{00655     ProgramBinder progBinder(prog);}
\DoxyCodeLine{00656 }
\DoxyCodeLine{00657     \textcolor{comment}{// Bind uniform parameters}}
\DoxyCodeLine{00658     bindParameters(prog, frame);}
\DoxyCodeLine{00659 }
\DoxyCodeLine{00660     prog-\/>setUniformValue(\textcolor{stringliteral}{"{}infiniteRect"{}}, infiniteRectF.m\_val[0],}
\DoxyCodeLine{00661                           infiniteRectF.m\_val[1], infiniteRectF.m\_val[2],}
\DoxyCodeLine{00662                           infiniteRectF.m\_val[3]);}
\DoxyCodeLine{00663 }
\DoxyCodeLine{00664     prog-\/>setUniformValueArray(\textcolor{stringliteral}{"{}inputBBox"{}}, inputBBoxes[0].m\_val,}
\DoxyCodeLine{00665                                \textcolor{keywordtype}{int}(inputBBoxes.size()), 4);}
\DoxyCodeLine{00666 }
\DoxyCodeLine{00667     \textcolor{comment}{// Perform transform feedback}}
\DoxyCodeLine{00668     \textcolor{keyword}{const} GLsizeiptr varyingSizes[] = \{\textcolor{keyword}{sizeof}(::RectF)\};}
\DoxyCodeLine{00669     GLvoid *bufs[]                  = \{bboxF.m\_val\};}
\DoxyCodeLine{00670 }
\DoxyCodeLine{00671     context.\mbox{\hyperlink{class_shading_context_a4af32748d5ba22eb1e09d3215004fd3c}{transformFeedback}}(1, varyingSizes, bufs);}
\DoxyCodeLine{00672   \}}
\DoxyCodeLine{00673 }
\DoxyCodeLine{00674   \textcolor{comment}{// Finalize output}}
\DoxyCodeLine{00675   bbox = (bboxF == infiniteRectF) ? TConsts::infiniteRectD : \mbox{\hyperlink{class_t_rect_t}{TRectD}}(bboxF);}
\DoxyCodeLine{00676   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00677 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_shader_fx_a03bd073b9f383c7c9dc336c27757acb0}\label{class_shader_fx_a03bd073b9f383c7c9dc336c27757acb0}} 
\index{ShaderFx@{ShaderFx}!getParamUIs@{getParamUIs}}
\index{getParamUIs@{getParamUIs}!ShaderFx@{ShaderFx}}
\doxysubsubsection{\texorpdfstring{getParamUIs()}{getParamUIs()}}
{\footnotesize\ttfamily void Shader\+Fx\+::get\+Param\+UIs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_t_param_u_i_concept}{TParam\+UIConcept}} $\ast$\&}]{params,  }\item[{int \&}]{length }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Returns a list of User Interface Concepts to be displayed when editing the fx parameters. \begin{DoxyNote}{Note}
Ownership of the returned array allocated with new\mbox{[}\mbox{]} is passed to callers. 
\end{DoxyNote}


Reimplemented from \mbox{\hyperlink{class_t_fx_a18766b107b77772d67c5678e7d832b18}{TFx}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00588                                                                 \{}
\DoxyCodeLine{00589   length = int(m\_uiConcepts.size());}
\DoxyCodeLine{00590   params = \textcolor{keyword}{new} \mbox{\hyperlink{class_t_param_u_i_concept}{TParamUIConcept}}[length];}
\DoxyCodeLine{00591 }
\DoxyCodeLine{00592   std::copy(m\_uiConcepts.begin(), m\_uiConcepts.end(), params);}
\DoxyCodeLine{00593 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_shader_fx_a75e7be102ea4268100835c37db6612be}\label{class_shader_fx_a75e7be102ea4268100835c37db6612be}} 
\index{ShaderFx@{ShaderFx}!initialize@{initialize}}
\index{initialize@{initialize}!ShaderFx@{ShaderFx}}
\doxysubsubsection{\texorpdfstring{initialize()}{initialize()}}
{\footnotesize\ttfamily void Shader\+Fx\+::initialize (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{00391                           \{}
\DoxyCodeLine{00392   \textcolor{keyword}{struct }\{}
\DoxyCodeLine{00393     \mbox{\hyperlink{class_shader_fx}{ShaderFx}} *m\_this;}
\DoxyCodeLine{00394 }
\DoxyCodeLine{00395     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addUiConcept(\textcolor{keyword}{const} \mbox{\hyperlink{class_shader_interface_1_1_parameter}{ShaderInterface::Parameter}} \&siParam,}
\DoxyCodeLine{00396                              \textcolor{keyword}{const} \mbox{\hyperlink{class_t_smart_pointer_t}{TParamP}} \&param) \{}
\DoxyCodeLine{00397       \textcolor{keywordflow}{if} (siParam.m\_concept.\mbox{\hyperlink{class_shader_interface_1_1_parameter_concept_af9cb35e7652ae495813e66fa03c89b78}{m\_type}} >= ShaderInterface::UI\_CONCEPTS \&\&}
\DoxyCodeLine{00398           siParam.m\_concept.\mbox{\hyperlink{class_shader_interface_1_1_parameter_concept_af9cb35e7652ae495813e66fa03c89b78}{m\_type}} < ShaderInterface::CONCEPTSCOUNT) \{}
\DoxyCodeLine{00399         m\_this-\/>m\_uiConcepts.push\_back(\mbox{\hyperlink{class_t_param_u_i_concept}{TParamUIConcept}}());}
\DoxyCodeLine{00400 }
\DoxyCodeLine{00401         \mbox{\hyperlink{class_t_param_u_i_concept}{TParamUIConcept}} \&uiConcept = m\_this-\/>m\_uiConcepts.back();}
\DoxyCodeLine{00402         uiConcept.\mbox{\hyperlink{class_t_param_u_i_concept_a2dbb7c954ca5f2441a6931945cf004a5}{m\_type}}           = ::l\_conceptTypes[siParam.m\_concept.\mbox{\hyperlink{class_shader_interface_1_1_parameter_concept_af9cb35e7652ae495813e66fa03c89b78}{m\_type}} -\/}
\DoxyCodeLine{00403                                             ShaderInterface::UI\_CONCEPTS];}
\DoxyCodeLine{00404         uiConcept.\mbox{\hyperlink{class_t_param_u_i_concept_ac857c2795b92f143b79f837e004b259d}{m\_label}}          = siParam.m\_concept.\mbox{\hyperlink{class_shader_interface_1_1_parameter_concept_a755f727d6fee5fa8f471f5cff2e380de}{m\_label}}.toStdString();}
\DoxyCodeLine{00405         uiConcept.\mbox{\hyperlink{class_t_param_u_i_concept_a7d7d017bbdc169f5b2c6c07fb69145c6}{m\_params}}.push\_back(param);}
\DoxyCodeLine{00406       \}}
\DoxyCodeLine{00407     \}}
\DoxyCodeLine{00408 }
\DoxyCodeLine{00409     \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addUiConcept(\textcolor{keyword}{const} \mbox{\hyperlink{class_shader_interface_1_1_parameter_concept}{ShaderInterface::ParameterConcept}} \&\textcolor{keyword}{concept}) \{}
\DoxyCodeLine{00410       \textcolor{keywordflow}{if} (!\textcolor{keyword}{concept}.isUI() || \textcolor{keyword}{concept}.m\_parameterNames.empty()) \textcolor{keywordflow}{return};}
\DoxyCodeLine{00411 }
\DoxyCodeLine{00412       \mbox{\hyperlink{class_t_param_u_i_concept}{TParamUIConcept}} uiConcept = \{}
\DoxyCodeLine{00413           ::l\_conceptTypes[\textcolor{keyword}{concept}.m\_type -\/ ShaderInterface::UI\_CONCEPTS],}
\DoxyCodeLine{00414           \textcolor{keyword}{concept}.\mbox{\hyperlink{class_t_param_u_i_concept_ac857c2795b92f143b79f837e004b259d}{m\_label}}.toStdString()\};}
\DoxyCodeLine{00415 }
\DoxyCodeLine{00416       \textcolor{keywordtype}{int} n, nCount = int(\textcolor{keyword}{concept}.m\_parameterNames.size());}
\DoxyCodeLine{00417       \textcolor{keywordflow}{for} (n = 0; n != nCount; ++n) \{}
\DoxyCodeLine{00418         \mbox{\hyperlink{class_t_param}{TParam}} *param = m\_this-\/>getParams()-\/>getParam(}
\DoxyCodeLine{00419             \textcolor{keyword}{concept}.m\_parameterNames[n].toStdString());}
\DoxyCodeLine{00420         \textcolor{keywordflow}{if} (!param) \textcolor{keywordflow}{break};}
\DoxyCodeLine{00421 }
\DoxyCodeLine{00422         uiConcept.\mbox{\hyperlink{class_t_param_u_i_concept_a7d7d017bbdc169f5b2c6c07fb69145c6}{m\_params}}.push\_back(param);}
\DoxyCodeLine{00423       \}}
\DoxyCodeLine{00424 }
\DoxyCodeLine{00425       \textcolor{keywordflow}{if} (uiConcept.\mbox{\hyperlink{class_t_param_u_i_concept_a7d7d017bbdc169f5b2c6c07fb69145c6}{m\_params}}.size() == \textcolor{keyword}{concept}.m\_parameterNames.size())}
\DoxyCodeLine{00426         m\_this-\/>m\_uiConcepts.push\_back(uiConcept);}
\DoxyCodeLine{00427     \}}
\DoxyCodeLine{00428 }
\DoxyCodeLine{00429   \} locals = \{\textcolor{keyword}{this}\};}
\DoxyCodeLine{00430 }
\DoxyCodeLine{00431   assert(m\_params.empty());  \textcolor{comment}{// Interfaces should not be re-\/set}}
\DoxyCodeLine{00432 }
\DoxyCodeLine{00433   \textcolor{comment}{// Allocate parameters following the specified interface}}
\DoxyCodeLine{00434   \textcolor{keyword}{const} std::vector<ShaderInterface::Parameter> \&siParams =}
\DoxyCodeLine{00435       m\_shaderInterface-\/>parameters();}
\DoxyCodeLine{00436 }
\DoxyCodeLine{00437   \textcolor{keywordtype}{int} p, pCount = int(siParams.size());}
\DoxyCodeLine{00438   m\_params.reserve(pCount);}
\DoxyCodeLine{00439 }
\DoxyCodeLine{00440   \textcolor{keywordflow}{for} (p = 0; p != pCount; ++p) \{}
\DoxyCodeLine{00441     \textcolor{keyword}{const} \mbox{\hyperlink{class_shader_interface_1_1_parameter}{ShaderInterface::Parameter}} \&siParam = siParams[p];}
\DoxyCodeLine{00442 }
\DoxyCodeLine{00443     \textcolor{keywordflow}{switch} (siParam.m\_type) \{}
\DoxyCodeLine{00444     \textcolor{keywordflow}{case} ShaderInterface::BOOL: \{}
\DoxyCodeLine{00445       TBoolParamP param(siParam.m\_default.m\_bool);}
\DoxyCodeLine{00446 }
\DoxyCodeLine{00447       m\_params.push\_back(param);}
\DoxyCodeLine{00448       bindParam(\textcolor{keyword}{this}, siParam.m\_name.toStdString(),}
\DoxyCodeLine{00449                 *boost::unsafe\_any\_cast<TBoolParamP>(\&m\_params.back()));}
\DoxyCodeLine{00450 }
\DoxyCodeLine{00451       \textcolor{keywordflow}{break};}
\DoxyCodeLine{00452     \}}
\DoxyCodeLine{00453 }
\DoxyCodeLine{00454     \textcolor{keywordflow}{case} ShaderInterface::FLOAT: \{}
\DoxyCodeLine{00455       TDoubleParamP param(siParam.m\_default.m\_float);}
\DoxyCodeLine{00456       param-\/>setValueRange(siParam.m\_range[0].m\_float,}
\DoxyCodeLine{00457                            siParam.m\_range[1].m\_float);}
\DoxyCodeLine{00458 }
\DoxyCodeLine{00459       locals.addUiConcept(siParam, param);}
\DoxyCodeLine{00460 }
\DoxyCodeLine{00461       \textcolor{keywordflow}{switch} (siParam.m\_concept.\mbox{\hyperlink{class_shader_interface_1_1_parameter_concept_af9cb35e7652ae495813e66fa03c89b78}{m\_type}}) \{}
\DoxyCodeLine{00462       \textcolor{keywordflow}{case} ShaderInterface::PERCENT:}
\DoxyCodeLine{00463         param-\/>setMeasureName(l\_measureNames[PERCENT]);}
\DoxyCodeLine{00464         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00465 }
\DoxyCodeLine{00466       \textcolor{keywordflow}{case} ShaderInterface::LENGTH:}
\DoxyCodeLine{00467       \textcolor{keywordflow}{case} ShaderInterface::RADIUS\_UI:}
\DoxyCodeLine{00468       \textcolor{keywordflow}{case} ShaderInterface::WIDTH\_UI:}
\DoxyCodeLine{00469       \textcolor{keywordflow}{case} ShaderInterface::SIZE\_UI:}
\DoxyCodeLine{00470         param-\/>setMeasureName(l\_measureNames[LENGTH]);}
\DoxyCodeLine{00471         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00472 }
\DoxyCodeLine{00473       \textcolor{keywordflow}{case} ShaderInterface::ANGLE:}
\DoxyCodeLine{00474       \textcolor{keywordflow}{case} ShaderInterface::ANGLE\_UI:}
\DoxyCodeLine{00475         param-\/>setMeasureName(l\_measureNames[ANGLE]);}
\DoxyCodeLine{00476         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00477       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00478         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00479       \}}
\DoxyCodeLine{00480 }
\DoxyCodeLine{00481       m\_params.push\_back(param);}
\DoxyCodeLine{00482       bindParam(\textcolor{keyword}{this}, siParam.m\_name.toStdString(),}
\DoxyCodeLine{00483                 *boost::unsafe\_any\_cast<TDoubleParamP>(\&m\_params.back()));}
\DoxyCodeLine{00484       \textcolor{keywordflow}{break};}
\DoxyCodeLine{00485     \}}
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487     \textcolor{keywordflow}{case} ShaderInterface::VEC2: \{}
\DoxyCodeLine{00488       TPointParamP param(}
\DoxyCodeLine{00489           \mbox{\hyperlink{class_t_point_t}{TPointD}}(siParam.m\_default.m\_vec2[0], siParam.m\_default.m\_vec2[1]));}
\DoxyCodeLine{00490 }
\DoxyCodeLine{00491       param-\/>getX()-\/>setValueRange(siParam.m\_range[0].m\_vec2[0],}
\DoxyCodeLine{00492                                    siParam.m\_range[1].m\_vec2[0]);}
\DoxyCodeLine{00493       param-\/>getY()-\/>setValueRange(siParam.m\_range[0].m\_vec2[1],}
\DoxyCodeLine{00494                                    siParam.m\_range[1].m\_vec2[1]);}
\DoxyCodeLine{00495 }
\DoxyCodeLine{00496       locals.addUiConcept(siParam, param);}
\DoxyCodeLine{00497 }
\DoxyCodeLine{00498       \textcolor{keywordflow}{switch} (siParam.m\_concept.\mbox{\hyperlink{class_shader_interface_1_1_parameter_concept_af9cb35e7652ae495813e66fa03c89b78}{m\_type}}) \{}
\DoxyCodeLine{00499       \textcolor{keywordflow}{case} ShaderInterface::PERCENT:}
\DoxyCodeLine{00500         param-\/>getX()-\/>setMeasureName(l\_measureNames[PERCENT]);}
\DoxyCodeLine{00501         param-\/>getY()-\/>setMeasureName(l\_measureNames[PERCENT]);}
\DoxyCodeLine{00502         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00503 }
\DoxyCodeLine{00504       \textcolor{keywordflow}{case} ShaderInterface::LENGTH:}
\DoxyCodeLine{00505       \textcolor{keywordflow}{case} ShaderInterface::POINT:}
\DoxyCodeLine{00506       \textcolor{keywordflow}{case} ShaderInterface::POINT\_UI:}
\DoxyCodeLine{00507       \textcolor{keywordflow}{case} ShaderInterface::VECTOR\_UI:}
\DoxyCodeLine{00508       \textcolor{keywordflow}{case} ShaderInterface::WIDTH\_UI:}
\DoxyCodeLine{00509       \textcolor{keywordflow}{case} ShaderInterface::SIZE\_UI:}
\DoxyCodeLine{00510         param-\/>getX()-\/>setMeasureName(l\_measureNames[LENGTH]);}
\DoxyCodeLine{00511         param-\/>getY()-\/>setMeasureName(l\_measureNames[LENGTH]);}
\DoxyCodeLine{00512         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00513 }
\DoxyCodeLine{00514       \textcolor{keywordflow}{case} ShaderInterface::ANGLE:}
\DoxyCodeLine{00515       \textcolor{keywordflow}{case} ShaderInterface::ANGLE\_UI:}
\DoxyCodeLine{00516         param-\/>getX()-\/>setMeasureName(l\_measureNames[ANGLE]);}
\DoxyCodeLine{00517         param-\/>getY()-\/>setMeasureName(l\_measureNames[ANGLE]);}
\DoxyCodeLine{00518         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00519       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00520         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00521       \}}
\DoxyCodeLine{00522 }
\DoxyCodeLine{00523       m\_params.push\_back(param);}
\DoxyCodeLine{00524       bindParam(\textcolor{keyword}{this}, siParam.m\_name.toStdString(),}
\DoxyCodeLine{00525                 *boost::unsafe\_any\_cast<TPointParamP>(\&m\_params.back()));}
\DoxyCodeLine{00526       \textcolor{keywordflow}{break};}
\DoxyCodeLine{00527     \}}
\DoxyCodeLine{00528 }
\DoxyCodeLine{00529     \textcolor{keywordflow}{case} ShaderInterface::INT: \{}
\DoxyCodeLine{00530       TIntParamP param(siParam.m\_default.m\_int);}
\DoxyCodeLine{00531       param-\/>setValueRange(siParam.m\_range[0].m\_int, siParam.m\_range[1].m\_int);}
\DoxyCodeLine{00532 }
\DoxyCodeLine{00533       m\_params.push\_back(param);}
\DoxyCodeLine{00534       bindParam(\textcolor{keyword}{this}, siParam.m\_name.toStdString(),}
\DoxyCodeLine{00535                 *boost::unsafe\_any\_cast<TIntParamP>(\&m\_params.back()));}
\DoxyCodeLine{00536       \textcolor{keywordflow}{break};}
\DoxyCodeLine{00537     \}}
\DoxyCodeLine{00538 }
\DoxyCodeLine{00539     \textcolor{keywordflow}{case} ShaderInterface::RGBA: \{}
\DoxyCodeLine{00540       TPixelParamP param(}
\DoxyCodeLine{00541           TPixel32(siParam.m\_default.m\_rgba[0], siParam.m\_default.m\_rgba[1],}
\DoxyCodeLine{00542                    siParam.m\_default.m\_rgba[2], siParam.m\_default.m\_rgba[3]));}
\DoxyCodeLine{00543 }
\DoxyCodeLine{00544       m\_params.push\_back(param);}
\DoxyCodeLine{00545       bindParam(\textcolor{keyword}{this}, siParam.m\_name.toStdString(),}
\DoxyCodeLine{00546                 *boost::unsafe\_any\_cast<TPixelParamP>(\&m\_params.back()));}
\DoxyCodeLine{00547       \textcolor{keywordflow}{break};}
\DoxyCodeLine{00548     \}}
\DoxyCodeLine{00549 }
\DoxyCodeLine{00550     \textcolor{keywordflow}{case} ShaderInterface::RGB: \{}
\DoxyCodeLine{00551       TPixelParamP param(TPixel32(siParam.m\_default.m\_rgb[0],}
\DoxyCodeLine{00552                                   siParam.m\_default.m\_rgb[1],}
\DoxyCodeLine{00553                                   siParam.m\_default.m\_rgb[2]));}
\DoxyCodeLine{00554 }
\DoxyCodeLine{00555       param-\/>enableMatte(\textcolor{keyword}{false});}
\DoxyCodeLine{00556 }
\DoxyCodeLine{00557       m\_params.push\_back(param);}
\DoxyCodeLine{00558       bindParam(\textcolor{keyword}{this}, siParam.m\_name.toStdString(),}
\DoxyCodeLine{00559                 *boost::unsafe\_any\_cast<TPixelParamP>(\&m\_params.back()));}
\DoxyCodeLine{00560       \textcolor{keywordflow}{break};}
\DoxyCodeLine{00561     \}}
\DoxyCodeLine{00562     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00563       \textcolor{keywordflow}{break};}
\DoxyCodeLine{00564     \}}
\DoxyCodeLine{00565   \}}
\DoxyCodeLine{00566 }
\DoxyCodeLine{00567   \textcolor{comment}{// Add composite UI concepts}}
\DoxyCodeLine{00568   \textcolor{keyword}{const} std::vector<ShaderInterface::ParameterConcept> \&parConcepts =}
\DoxyCodeLine{00569       m\_shaderInterface-\/>m\_parConcepts;}
\DoxyCodeLine{00570 }
\DoxyCodeLine{00571   \textcolor{keywordtype}{int} c, cCount = int(parConcepts.size());}
\DoxyCodeLine{00572   \textcolor{keywordflow}{for} (c = 0; c != cCount; ++c) locals.addUiConcept(parConcepts[c]);}
\DoxyCodeLine{00573 }
\DoxyCodeLine{00574   \textcolor{comment}{// Add input ports}}
\DoxyCodeLine{00575   \textcolor{keyword}{const} std::vector<QString> \&inputPorts = m\_shaderInterface-\/>inputPorts();}
\DoxyCodeLine{00576 }
\DoxyCodeLine{00577   \textcolor{keywordtype}{int} i, iCount = int(inputPorts.size());}
\DoxyCodeLine{00578   m\_inputPorts.reserve(iCount);}
\DoxyCodeLine{00579 }
\DoxyCodeLine{00580   \textcolor{keywordflow}{for} (i = 0; i != iCount; ++i) \{}
\DoxyCodeLine{00581     m\_inputPorts.push\_back(\textcolor{keyword}{new} \mbox{\hyperlink{class_t_raster_fx_port}{TRasterFxPort}});}
\DoxyCodeLine{00582     \mbox{\hyperlink{class_t_fx_af0ccf8d65934ed9f7a62d3b45ee5f2b6}{addInputPort}}(inputPorts[i].toStdString(), m\_inputPorts[i]);}
\DoxyCodeLine{00583   \}}
\DoxyCodeLine{00584 \}}

\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
E\+:/opentoonz/toonz/sources/stdfx/shaderfx.\+cpp\end{DoxyCompactItemize}
