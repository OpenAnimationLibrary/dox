\hypertarget{namespacetcg_1_1poly__ops}{}\doxysection{tcg\+::poly\+\_\+ops Namespace Reference}
\label{namespacetcg_1_1poly__ops}\index{tcg::poly\_ops@{tcg::poly\_ops}}


Contains useful functions for operating with polynomials.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Scalar $>$ }\\Scalar \mbox{\hyperlink{namespacetcg_1_1poly__ops_a70aeb5c2535d8ec2b25e2e07f79b5fc4}{evaluate}} (const Scalar poly\mbox{[}$\,$\mbox{]}, int deg, Scalar x)
\begin{DoxyCompactList}\small\item\em Evaluates a polynomial using Horner\textquotesingle{}s algorithm. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespacetcg_1_1poly__ops_ab2c0be0452e2ff8440eb337ddedd3e59}{reduce\+Degree}} (const Scalar poly\mbox{[}$\,$\mbox{]}, int \&deg, Scalar tolerance)
\begin{DoxyCompactList}\small\item\em Reduces the degree of the input polynomial, discarding all leading coefficients whose absolute value is below the specified tolerance threshold. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename A , typename B , typename C , int deg$>$ }\\void \mbox{\hyperlink{namespacetcg_1_1poly__ops_a2ce6c8bcbc58bd7f994a759686a09f87}{add}} (const A(\&poly1)\mbox{[}deg\mbox{]}, const B(\&poly2)\mbox{[}deg\mbox{]}, C(\&result)\mbox{[}deg\mbox{]})
\begin{DoxyCompactList}\small\item\em Adds two polynomials and returns the sum. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename A , typename B , typename C , int deg$>$ }\\void \mbox{\hyperlink{namespacetcg_1_1poly__ops_a0947d0d2f6953ac9ef649b7f26f55e36}{sub}} (const A(\&poly1)\mbox{[}deg\mbox{]}, const B(\&poly2)\mbox{[}deg\mbox{]}, C(\&result)\mbox{[}deg\mbox{]})
\begin{DoxyCompactList}\small\item\em Subtracts two polynomials /p poly1 and {\ttfamily poly2} and returns the difference {\ttfamily poly1 -\/ poly2}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename A , typename B , typename C , int deg1, int deg2, int degR$>$ }\\void \mbox{\hyperlink{namespacetcg_1_1poly__ops_aed9052d61e84710a8a2ffa6288912e4a}{mul}} (const A(\&poly1)\mbox{[}deg1\mbox{]}, const B(\&poly2)\mbox{[}deg2\mbox{]}, C(\&result)\mbox{[}degR\mbox{]})
\begin{DoxyCompactList}\small\item\em Multiplies two polynomials into a polynomial whose degree is the {\itshape sum} of the multiplicands\textquotesingle{} degrees. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename A , typename B , typename C , int deg1, int deg2, int degR$>$ }\\void \mbox{\hyperlink{namespacetcg_1_1poly__ops_ad4299a9653d24554e97e3e75a34dfeef}{chain}} (const A(\&poly1)\mbox{[}deg1\mbox{]}, const B(\&poly2)\mbox{[}deg2\mbox{]}, C(\&result)\mbox{[}degR\mbox{]})
\begin{DoxyCompactList}\small\item\em Calculates the chaining {\ttfamily poly1 o poly2} of two given polynomial {\ttfamily poly1} and {\ttfamily poly2}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename A , typename B , int deg, int degR$>$ }\\void \mbox{\hyperlink{namespacetcg_1_1poly__ops_a0e0e986308336fb6fcd67f141a2e21c8}{derivative}} (const A(\&poly)\mbox{[}deg\mbox{]}, B(\&result)\mbox{[}degR\mbox{]})
\item 
{\footnotesize template$<$typename Scalar $>$ }\\unsigned int \mbox{\hyperlink{namespacetcg_1_1poly__ops_aa241ac7ed1e6875500825065ac00bb40}{solve\+\_\+1}} (Scalar c\mbox{[}2\mbox{]}, Scalar s\mbox{[}1\mbox{]}, Scalar tol=0)
\begin{DoxyCompactList}\small\item\em Solves the 1st degree equation\+: \$c\mbox{[}1\mbox{]} t + c\mbox{[}0\mbox{]} = 0\$. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\unsigned int \mbox{\hyperlink{namespacetcg_1_1poly__ops_a2d0ee1f8b032593a7fad7ef97dc9e14b}{solve\+\_\+2}} (Scalar c\mbox{[}3\mbox{]}, Scalar s\mbox{[}2\mbox{]}, Scalar tol=0)
\begin{DoxyCompactList}\small\item\em Solves the 2nd degree equation\+: \$c\mbox{[}2\mbox{]} t$^\wedge$2 + c\mbox{[}1\mbox{]} t + c\mbox{[}0\mbox{]} = 0\$. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\unsigned int \mbox{\hyperlink{namespacetcg_1_1poly__ops_aef47a1bb2cd66679b420dc8bff023ba5}{solve\+\_\+3}} (Scalar c\mbox{[}4\mbox{]}, Scalar s\mbox{[}3\mbox{]}, Scalar tol=0)
\begin{DoxyCompactList}\small\item\em Solves the 3rd degree equation\+: \$c\mbox{[}3\mbox{]}t$^\wedge$3 + c\mbox{[}2\mbox{]} t$^\wedge$2 + c\mbox{[}1\mbox{]} t + c\mbox{[}0\mbox{]} = 0\$. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Contains useful functions for operating with polynomials. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacetcg_1_1poly__ops_a2ce6c8bcbc58bd7f994a759686a09f87}\label{namespacetcg_1_1poly__ops_a2ce6c8bcbc58bd7f994a759686a09f87}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!add@{add}}
\index{add@{add}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{add()}{add()}}
{\footnotesize\ttfamily template$<$typename A , typename B , typename C , int deg$>$ \\
void tcg\+::poly\+\_\+ops\+::add (\begin{DoxyParamCaption}\item[{const A(\&)}]{poly1\mbox{[}deg\mbox{]},  }\item[{const B(\&)}]{poly2\mbox{[}deg\mbox{]},  }\item[{C(\&)}]{result\mbox{[}deg\mbox{]} }\end{DoxyParamCaption})}



Adds two polynomials and returns the sum. 

\begin{DoxyRemark}{Remarks}
The supplied polynomials can actually be the same. 
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em poly1} & First polynomial addendum. \\
\hline
{\em poly2} & Second polynomial addendum. \\
\hline
{\em result} & Resulting sum. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00069 \{}
\DoxyCodeLine{00070   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} d = 0; d != deg; ++d) result[d] = poly1[d] + poly2[d];}
\DoxyCodeLine{00071 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetcg_1_1poly__ops_ad4299a9653d24554e97e3e75a34dfeef}\label{namespacetcg_1_1poly__ops_ad4299a9653d24554e97e3e75a34dfeef}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!chain@{chain}}
\index{chain@{chain}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{chain()}{chain()}}
{\footnotesize\ttfamily template$<$typename A , typename B , typename C , int deg1, int deg2, int degR$>$ \\
void tcg\+::poly\+\_\+ops\+::chain (\begin{DoxyParamCaption}\item[{const A(\&)}]{poly1\mbox{[}deg1\mbox{]},  }\item[{const B(\&)}]{poly2\mbox{[}deg2\mbox{]},  }\item[{C(\&)}]{result\mbox{[}deg\+R\mbox{]} }\end{DoxyParamCaption})}



Calculates the chaining {\ttfamily poly1 o poly2} of two given polynomial {\ttfamily poly1} and {\ttfamily poly2}. 

\begin{DoxyWarning}{Warning}
The resulting polynomial is currently {\bfseries{not allowed}} to be one of the multiplicands. 

This function is still {\bfseries{untested}}. 
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em poly1} & First polynomial. \\
\hline
{\em poly2} & Second polynomial. \\
\hline
{\em result} & Resulting polynomial. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00123 \{}
\DoxyCodeLine{00124   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} a = 0; a != deg1; ++a) \{}
\DoxyCodeLine{00125     B pow[degR][2] = \{\{\}\};}
\DoxyCodeLine{00126 }
\DoxyCodeLine{00127     \textcolor{comment}{// Build poly2 powers}}
\DoxyCodeLine{00128     \{}
\DoxyCodeLine{00129       std::copy(poly2, poly2 + deg2, pow[1]);}
\DoxyCodeLine{00130 }
\DoxyCodeLine{00131       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p = 1; p < a; ++p) poly\_mul(pow[p \% 2], poly2, pow[(p + 1) \% 2]);}
\DoxyCodeLine{00132     \}}
\DoxyCodeLine{00133 }
\DoxyCodeLine{00134     B(\&pow\_add)[degR] = pow[a \% 2];}
\DoxyCodeLine{00135 }
\DoxyCodeLine{00136     \textcolor{comment}{// multiply by poly1[a]}}
\DoxyCodeLine{00137     C addendum[degR];}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} c = 0; c != degR; ++c) addendum[c] = poly1[c] * pow\_add[c];}
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141     poly\_add(addendum, result);}
\DoxyCodeLine{00142   \}}
\DoxyCodeLine{00143 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetcg_1_1poly__ops_a0e0e986308336fb6fcd67f141a2e21c8}\label{namespacetcg_1_1poly__ops_a0e0e986308336fb6fcd67f141a2e21c8}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!derivative@{derivative}}
\index{derivative@{derivative}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{derivative()}{derivative()}}
{\footnotesize\ttfamily template$<$typename A , typename B , int deg, int degR$>$ \\
void tcg\+::poly\+\_\+ops\+::derivative (\begin{DoxyParamCaption}\item[{const A(\&)}]{poly\mbox{[}deg\mbox{]},  }\item[{B(\&)}]{result\mbox{[}deg\+R\mbox{]} }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em poly} & Polynomial to be derived. \\
\hline
{\em result} & Resulting derivative polynomial. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00150 \{}
\DoxyCodeLine{00151   \mbox{\hyperlink{macros_8h_afb05acd7751b0243f9571b72e13b29cc}{TCG\_STATIC\_ASSERT}}(degR == deg -\/ 1);}
\DoxyCodeLine{00152 }
\DoxyCodeLine{00153   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} c = 1; c != deg; ++c) result[c -\/ 1] = c * poly[c];}
\DoxyCodeLine{00154 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00070}{TCG\+\_\+\+STATIC\+\_\+\+ASSERT}}.

\mbox{\Hypertarget{namespacetcg_1_1poly__ops_a70aeb5c2535d8ec2b25e2e07f79b5fc4}\label{namespacetcg_1_1poly__ops_a70aeb5c2535d8ec2b25e2e07f79b5fc4}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!evaluate@{evaluate}}
\index{evaluate@{evaluate}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{evaluate()}{evaluate()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
Scalar tcg\+::poly\+\_\+ops\+::evaluate (\begin{DoxyParamCaption}\item[{const Scalar}]{poly\mbox{[}$\,$\mbox{]},  }\item[{int}]{deg,  }\item[{Scalar}]{x }\end{DoxyParamCaption})}



Evaluates a polynomial using Horner\textquotesingle{}s algorithm. 

\begin{DoxyReturn}{Returns}
The value of the input polynomial at the specified parameter 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em poly} & Coefficients of the input polynomial, indexed by degree \\
\hline
{\em deg} & Degree of the polynomial function \\
\hline
{\em x} & Parameter the polynomial will be evaluated on \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00034 \{}
\DoxyCodeLine{00035   \textcolor{comment}{// ((poly[deg] * x) + poly[deg-\/1]) * x + poly[deg -\/ 2] + ...}}
\DoxyCodeLine{00036 }
\DoxyCodeLine{00037   Scalar value = poly[deg];}
\DoxyCodeLine{00038   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} d = deg -\/ 1; d >= 0; -\/-\/d) value = value * x + poly[d];}
\DoxyCodeLine{00039 }
\DoxyCodeLine{00040   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{00041 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetcg_1_1poly__ops_aed9052d61e84710a8a2ffa6288912e4a}\label{namespacetcg_1_1poly__ops_aed9052d61e84710a8a2ffa6288912e4a}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!mul@{mul}}
\index{mul@{mul}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{mul()}{mul()}}
{\footnotesize\ttfamily template$<$typename A , typename B , typename C , int deg1, int deg2, int degR$>$ \\
void tcg\+::poly\+\_\+ops\+::mul (\begin{DoxyParamCaption}\item[{const A(\&)}]{poly1\mbox{[}deg1\mbox{]},  }\item[{const B(\&)}]{poly2\mbox{[}deg2\mbox{]},  }\item[{C(\&)}]{result\mbox{[}deg\+R\mbox{]} }\end{DoxyParamCaption})}



Multiplies two polynomials into a polynomial whose degree is the {\itshape sum} of the multiplicands\textquotesingle{} degrees. 

\begin{DoxyWarning}{Warning}
The resulting polynomial is currently {\bfseries{not allowed}} to be one of the multiplicands. 
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em poly1} & First multiplicand. \\
\hline
{\em poly2} & Second multiplicand. \\
\hline
{\em result} & Resulting polynomial. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00100 \{}
\DoxyCodeLine{00101   \mbox{\hyperlink{macros_8h_afb05acd7751b0243f9571b72e13b29cc}{TCG\_STATIC\_ASSERT}}(degR == deg1 + deg2 -\/ 1);}
\DoxyCodeLine{00102 }
\DoxyCodeLine{00103   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} a = 0; a != deg1; ++a) \{}
\DoxyCodeLine{00104     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} b = 0; b != deg2; ++b) result[a + b] += poly1[a] * poly2[b];}
\DoxyCodeLine{00105   \}}
\DoxyCodeLine{00106 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00070}{TCG\+\_\+\+STATIC\+\_\+\+ASSERT}}.

\mbox{\Hypertarget{namespacetcg_1_1poly__ops_ab2c0be0452e2ff8440eb337ddedd3e59}\label{namespacetcg_1_1poly__ops_ab2c0be0452e2ff8440eb337ddedd3e59}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!reduceDegree@{reduceDegree}}
\index{reduceDegree@{reduceDegree}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{reduceDegree()}{reduceDegree()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void tcg\+::poly\+\_\+ops\+::reduce\+Degree (\begin{DoxyParamCaption}\item[{const Scalar}]{poly\mbox{[}$\,$\mbox{]},  }\item[{int \&}]{deg,  }\item[{Scalar}]{tolerance }\end{DoxyParamCaption})}



Reduces the degree of the input polynomial, discarding all leading coefficients whose absolute value is below the specified tolerance threshold. 


\begin{DoxyParams}{Parameters}
{\em poly} & Input polynomial to be reduced. \\
\hline
{\em deg} & Input/output polynomial degree. \\
\hline
{\em tolerance} & Coefficients threshold to reduce the polynomial with. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00055       \{}
\DoxyCodeLine{00056   \textcolor{keywordflow}{while} ((deg > 0) \&\& (std::abs(poly[deg]) < tolerance)) -\/-\/deg;}
\DoxyCodeLine{00057 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetcg_1_1poly__ops_aa241ac7ed1e6875500825065ac00bb40}\label{namespacetcg_1_1poly__ops_aa241ac7ed1e6875500825065ac00bb40}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!solve\_1@{solve\_1}}
\index{solve\_1@{solve\_1}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{solve\_1()}{solve\_1()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
unsigned int tcg\+::poly\+\_\+ops\+::solve\+\_\+1 (\begin{DoxyParamCaption}\item[{Scalar}]{c\mbox{[}2\mbox{]},  }\item[{Scalar}]{s\mbox{[}1\mbox{]},  }\item[{Scalar}]{tol = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Solves the 1st degree equation\+: \$c\mbox{[}1\mbox{]} t + c\mbox{[}0\mbox{]} = 0\$. 

\begin{DoxyReturn}{Returns}
The number of solutions found under the specified divide-\/by tolerance 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em c} & Polynomial coefficients array \\
\hline
{\em s} & Solutions array \\
\hline
{\em tol} & Leading coefficient tolerance, the equation has no solution if the leading coefficient is below this threshold \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00170 \{}
\DoxyCodeLine{00171   \textcolor{keywordflow}{if} (std::abs(c[1]) <= tol) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00172 }
\DoxyCodeLine{00173   s[0] = -\/c[0] / c[1];}
\DoxyCodeLine{00174   \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{00175 \}}

\end{DoxyCode}


Referenced by \mbox{\hyperlink{l00187}{solve\+\_\+2()}}.

\mbox{\Hypertarget{namespacetcg_1_1poly__ops_a2d0ee1f8b032593a7fad7ef97dc9e14b}\label{namespacetcg_1_1poly__ops_a2d0ee1f8b032593a7fad7ef97dc9e14b}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!solve\_2@{solve\_2}}
\index{solve\_2@{solve\_2}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{solve\_2()}{solve\_2()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
unsigned int tcg\+::poly\+\_\+ops\+::solve\+\_\+2 (\begin{DoxyParamCaption}\item[{Scalar}]{c\mbox{[}3\mbox{]},  }\item[{Scalar}]{s\mbox{[}2\mbox{]},  }\item[{Scalar}]{tol = {\ttfamily 0} }\end{DoxyParamCaption})}



Solves the 2nd degree equation\+: \$c\mbox{[}2\mbox{]} t$^\wedge$2 + c\mbox{[}1\mbox{]} t + c\mbox{[}0\mbox{]} = 0\$. 

\begin{DoxyReturn}{Returns}
The number of \#real\# solutions found under the specified divide-\/by tolerance
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The returned solutions are sorted, with \$s\mbox{[}0\mbox{]} \texorpdfstring{$<$}{<}= s\mbox{[}1\mbox{]}\$ 
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em c} & Polynomial coefficients array \\
\hline
{\em s} & Solutions array \\
\hline
{\em tol} & Leading coefficient tolerance, the equation has no solution if the leading coefficient is below this threshold \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00193 \{}
\DoxyCodeLine{00194   \textcolor{keywordflow}{if} (std::abs(c[2]) <= tol)}
\DoxyCodeLine{00195     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetcg_1_1poly__ops_aa241ac7ed1e6875500825065ac00bb40}{solve\_1}}(c, s, tol);  \textcolor{comment}{// Reduces to first degree}}
\DoxyCodeLine{00196 }
\DoxyCodeLine{00197   Scalar nc[2] = \{}
\DoxyCodeLine{00198       c[0] / c[2],}
\DoxyCodeLine{00199       c[1] / (c[2] + c[2])\};  \textcolor{comment}{// NOTE: nc[1] gets further divided by 2}}
\DoxyCodeLine{00200 }
\DoxyCodeLine{00201   Scalar delta = nc[1] * nc[1] -\/ nc[0];}
\DoxyCodeLine{00202   \textcolor{keywordflow}{if} (delta < 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00203 }
\DoxyCodeLine{00204   delta = sqrt(delta);}
\DoxyCodeLine{00205 }
\DoxyCodeLine{00206   s[0] = -\/delta -\/ nc[1];}
\DoxyCodeLine{00207   s[1] = delta -\/ nc[1];}
\DoxyCodeLine{00208 }
\DoxyCodeLine{00209   \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{00210 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00164}{solve\+\_\+1()}}.



Referenced by \mbox{\hyperlink{l00223}{solve\+\_\+3()}}.

\mbox{\Hypertarget{namespacetcg_1_1poly__ops_aef47a1bb2cd66679b420dc8bff023ba5}\label{namespacetcg_1_1poly__ops_aef47a1bb2cd66679b420dc8bff023ba5}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!solve\_3@{solve\_3}}
\index{solve\_3@{solve\_3}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{solve\_3()}{solve\_3()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
unsigned int tcg\+::poly\+\_\+ops\+::solve\+\_\+3 (\begin{DoxyParamCaption}\item[{Scalar}]{c\mbox{[}4\mbox{]},  }\item[{Scalar}]{s\mbox{[}3\mbox{]},  }\item[{Scalar}]{tol = {\ttfamily 0} }\end{DoxyParamCaption})}



Solves the 3rd degree equation\+: \$c\mbox{[}3\mbox{]}t$^\wedge$3 + c\mbox{[}2\mbox{]} t$^\wedge$2 + c\mbox{[}1\mbox{]} t + c\mbox{[}0\mbox{]} = 0\$. 

\begin{DoxyReturn}{Returns}
The number of \#real\# solutions found under the specified divide-\/by tolerance
\end{DoxyReturn}
\begin{DoxyRemark}{Remarks}
The returned solutions are sorted, with \$s\mbox{[}0\mbox{]} \texorpdfstring{$<$}{<}= s\mbox{[}1\mbox{]} \texorpdfstring{$<$}{<}= s\mbox{[}2\mbox{]}\$ if the leading coefficient is below this threshold 
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em c} & Polynomial coefficients array \\
\hline
{\em s} & Solutions array \\
\hline
{\em tol} & Leading coefficient tolerance, the equation is reduced to 2nd degree \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00228 \{}
\DoxyCodeLine{00229   \textcolor{keywordflow}{if} (std::abs(c[3]) <= tol)}
\DoxyCodeLine{00230     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetcg_1_1poly__ops_a2d0ee1f8b032593a7fad7ef97dc9e14b}{solve\_2}}(c, s, tol);  \textcolor{comment}{// Reduces to second degree}}
\DoxyCodeLine{00231 }
\DoxyCodeLine{00232   Scalar nc[3] = \{c[0] / c[3], c[1] / c[3], c[2] / c[3]\};}
\DoxyCodeLine{00233 }
\DoxyCodeLine{00234   Scalar b2     = nc[2] * nc[2];}
\DoxyCodeLine{00235   Scalar p      = nc[1] -\/ b2 / 3;}
\DoxyCodeLine{00236   Scalar q      = nc[2] * (b2 + b2 -\/ 9 * nc[1]) / 27 + nc[0];}
\DoxyCodeLine{00237   Scalar p3     = p * p * p;}
\DoxyCodeLine{00238   Scalar d      = q * q + 4 * p3 / 27;}
\DoxyCodeLine{00239   Scalar offset = -\/nc[2] / 3;}
\DoxyCodeLine{00240 }
\DoxyCodeLine{00241   \textcolor{keywordflow}{if} (d >= 0) \{}
\DoxyCodeLine{00242     \textcolor{comment}{// Single solution}}
\DoxyCodeLine{00243     Scalar z = sqrt(d);}
\DoxyCodeLine{00244     Scalar u = (-\/q + z) / 2;}
\DoxyCodeLine{00245     Scalar v = (-\/q -\/ z) / 2;}
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247     u = (u < 0) ? -\/pow(-\/u, 1 / Scalar(3)) : pow(u, 1 / Scalar(3));}
\DoxyCodeLine{00248     v = (v < 0) ? -\/pow(-\/v, 1 / Scalar(3)) : pow(v, 1 / Scalar(3));}
\DoxyCodeLine{00249 }
\DoxyCodeLine{00250     s[0] = offset + u + v;}
\DoxyCodeLine{00251     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{00252   \}}
\DoxyCodeLine{00253 }
\DoxyCodeLine{00254   assert(p3 < 0);}
\DoxyCodeLine{00255 }
\DoxyCodeLine{00256   Scalar u = sqrt(-\/p / Scalar(3));}
\DoxyCodeLine{00257   Scalar v = acos(-\/sqrt(-\/27 / p3) * q / Scalar(2)) / Scalar(3);}
\DoxyCodeLine{00258   Scalar m = cos(v), n = sin(v) * 1.7320508075688772935274463415059;  \textcolor{comment}{// sqrt(3)}}
\DoxyCodeLine{00259 }
\DoxyCodeLine{00260   s[0] = offset -\/ u * (n + m);}
\DoxyCodeLine{00261   s[1] = offset + u * (n -\/ m);}
\DoxyCodeLine{00262   s[2] = offset + u * (m + m);}
\DoxyCodeLine{00263 }
\DoxyCodeLine{00264   assert(s[0] <= s[1] \&\& s[1] <= s[2]);}
\DoxyCodeLine{00265 }
\DoxyCodeLine{00266   \textcolor{keywordflow}{return} 3;}
\DoxyCodeLine{00267 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00187}{solve\+\_\+2()}}.

\mbox{\Hypertarget{namespacetcg_1_1poly__ops_a0947d0d2f6953ac9ef649b7f26f55e36}\label{namespacetcg_1_1poly__ops_a0947d0d2f6953ac9ef649b7f26f55e36}} 
\index{tcg::poly\_ops@{tcg::poly\_ops}!sub@{sub}}
\index{sub@{sub}!tcg::poly\_ops@{tcg::poly\_ops}}
\doxysubsubsection{\texorpdfstring{sub()}{sub()}}
{\footnotesize\ttfamily template$<$typename A , typename B , typename C , int deg$>$ \\
void tcg\+::poly\+\_\+ops\+::sub (\begin{DoxyParamCaption}\item[{const A(\&)}]{poly1\mbox{[}deg\mbox{]},  }\item[{const B(\&)}]{poly2\mbox{[}deg\mbox{]},  }\item[{C(\&)}]{result\mbox{[}deg\mbox{]} }\end{DoxyParamCaption})}



Subtracts two polynomials /p poly1 and {\ttfamily poly2} and returns the difference {\ttfamily poly1 -\/ poly2}. 


\begin{DoxyParams}{Parameters}
{\em poly1} & First polynomial addendum. \\
\hline
{\em poly2} & Second polynomial addendum. \\
\hline
{\em result} & Resulting difference. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00083 \{}
\DoxyCodeLine{00084   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} d = 0; d != deg; ++d) result[d] = poly1[d] -\/ poly2[d];}
\DoxyCodeLine{00085 \}}

\end{DoxyCode}
