\hypertarget{class_jacobian}{}\doxysection{Jacobian Class Reference}
\label{class_jacobian}\index{Jacobian@{Jacobian}}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum {\bfseries Update\+Mode} \{ \newline
{\bfseries JACOB\+\_\+\+Undefined} = 0
, {\bfseries JACOB\+\_\+\+Jacobian\+Transpose} = 1
, {\bfseries JACOB\+\_\+\+Pseudo\+Inverse} = 2
, {\bfseries JACOB\+\_\+\+DLS} = 3
, \newline
{\bfseries JACOB\+\_\+\+SDLS} = 4
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_jacobian_a4714b21bd15b45df4499143a8f7dd746}{Jacobian}} (\mbox{\hyperlink{class_i_k_skeleton}{IKSkeleton}} $\ast$skeleton, std\+::vector$<$ \mbox{\hyperlink{class_t_point_t}{TPointD}} $>$ \&target)
\item 
void \mbox{\hyperlink{class_jacobian_aa661382ab1057f0663a40d1d73127ad8}{compute\+Jacobian}} ()
\item 
void \mbox{\hyperlink{class_jacobian_a4e8a8e9abdcc9dfd6e47c13f533eb125}{add\+Target}} (\mbox{\hyperlink{class_t_point_t}{TPointD}} target\+Pos)
\item 
void \mbox{\hyperlink{class_jacobian_a93f20df15d29f76884323ac738efd3d4}{delet\+Last\+Target}} ()
\item 
void \mbox{\hyperlink{class_jacobian_a24eeaefbe56036da7af4a77e66f7891c}{set\+Target}} (int i, \mbox{\hyperlink{class_t_point_t}{TPointD}} target\+Pos)
\item 
void \mbox{\hyperlink{class_jacobian_aa7e8f89f2e5da915147a31590c3364cf}{Zero\+Delta\+Thetas}} ()
\item 
void \mbox{\hyperlink{class_jacobian_a0bb9b42c4eea995050f0c835aaeabcd1}{Calc\+Delta\+Thetas\+Transpose}} ()
\item 
void \mbox{\hyperlink{class_jacobian_ad9bd2e44047605346ffd5987c43fe211}{Calc\+Delta\+Thetas\+Pseudoinverse}} ()
\item 
void \mbox{\hyperlink{class_jacobian_ad3ad85d7621c0bb7f986a4b89cb5872d}{Calc\+Delta\+Thetas\+DLS}} ()
\item 
void \mbox{\hyperlink{class_jacobian_ad56901602ef95216b0c294b8e619d2a2}{Calc\+Delta\+Thetas\+DLSwith\+SVD}} ()
\item 
void \mbox{\hyperlink{class_jacobian_ad4a0f0bf23ec7caaacd33181248a4762}{Calc\+Delta\+Thetas\+SDLS}} ()
\item 
void \mbox{\hyperlink{class_jacobian_abb9b64db63ca485a053724d9b251a4dc}{Update\+Thetas}} ()
\item 
bool \mbox{\hyperlink{class_jacobian_aeabf2c921517d3f7f313701399e95b59}{check\+Joints\+Limit}} ()
\item 
void \mbox{\hyperlink{class_jacobian_a30a78448bc6bfa73d9c06a149bb9ff9e}{Updated\+SClamp\+Value}} ()
\item 
\mbox{\Hypertarget{class_jacobian_a8c192ad28dcbcb7b8853872a112e4605}\label{class_jacobian_a8c192ad28dcbcb7b8853872a112e4605}} 
void {\bfseries Draw\+Eigen\+Vectors} () const
\item 
void \mbox{\hyperlink{class_jacobian_a61c48f4ac57b20c0b007dde2d8f6038c}{Set\+Current\+Mode}} (Update\+Mode mode)
\item 
Update\+Mode \mbox{\hyperlink{class_jacobian_a5a2be3c1b9bdfca91fd0c6bbdb152558}{Get\+Current\+Mode}} () const
\item 
void \mbox{\hyperlink{class_jacobian_ad8fb54d90eb0fe47b0a1818f6818288f}{Set\+Damping\+DLS}} (double lambda)
\item 
void \mbox{\hyperlink{class_jacobian_a63640e5c70a253f167e235ccbdaec132}{Reset}} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{class_jacobian_af013b8875251778c3eb016d229ee1f1e}\label{class_jacobian_af013b8875251778c3eb016d229ee1f1e}} 
\index{Jacobian@{Jacobian}!UpdateMode@{UpdateMode}}
\index{UpdateMode@{UpdateMode}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{UpdateMode}{UpdateMode}}
{\footnotesize\ttfamily enum Jacobian\+::\+Update\+Mode}


\begin{DoxyCode}{0}
\DoxyCodeLine{00639                   \{}
\DoxyCodeLine{00640     JACOB\_Undefined         = 0,}
\DoxyCodeLine{00641     JACOB\_JacobianTranspose = 1,}
\DoxyCodeLine{00642     JACOB\_PseudoInverse     = 2,}
\DoxyCodeLine{00643     JACOB\_DLS               = 3,}
\DoxyCodeLine{00644     JACOB\_SDLS              = 4}
\DoxyCodeLine{00645   \};}

\end{DoxyCode}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_jacobian_a4714b21bd15b45df4499143a8f7dd746}\label{class_jacobian_a4714b21bd15b45df4499143a8f7dd746}} 
\index{Jacobian@{Jacobian}!Jacobian@{Jacobian}}
\index{Jacobian@{Jacobian}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{Jacobian()}{Jacobian()}}
{\footnotesize\ttfamily Jacobian\+::\+Jacobian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_i_k_skeleton}{IKSkeleton}} $\ast$}]{skeleton,  }\item[{std\+::vector$<$ \mbox{\hyperlink{class_t_point_t}{TPointD}} $>$ \&}]{target }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01065                                                                       \{}
\DoxyCodeLine{01066   Jacobian::skeleton = skeleton;}
\DoxyCodeLine{01067   nEffector          = skeleton-\/>getNumEffector();}
\DoxyCodeLine{01068   nJoint             = skeleton-\/>getNodeCount() -\/}
\DoxyCodeLine{01069            nEffector;  \textcolor{comment}{// numero dei giunti meno gli effettori}}
\DoxyCodeLine{01070   nRow = 2 * nEffector;}
\DoxyCodeLine{01071   nCol = nJoint;}
\DoxyCodeLine{01072 }
\DoxyCodeLine{01073   target = (targetPos);}
\DoxyCodeLine{01074 }
\DoxyCodeLine{01075   Jend.SetSize(nRow, nCol);  \textcolor{comment}{// Matrice jacobiana}}
\DoxyCodeLine{01076   Jend.SetZero();}
\DoxyCodeLine{01077 }
\DoxyCodeLine{01078   Jtarget.SetSize(}
\DoxyCodeLine{01079       nRow,}
\DoxyCodeLine{01080       nCol);  \textcolor{comment}{// Matrice jacobiana basta sulle posizioni dei targets (non usata)}}
\DoxyCodeLine{01081   Jtarget.SetZero();}
\DoxyCodeLine{01082 }
\DoxyCodeLine{01083   U.SetSize(nRow, nRow);  \textcolor{comment}{// matrice U per il calcolo SVD}}
\DoxyCodeLine{01084   w.SetLength(min(nRow, nCol));}
\DoxyCodeLine{01085   V.SetSize(nCol, nCol);  \textcolor{comment}{// matrice V per il calcolo SVD}}
\DoxyCodeLine{01086 }
\DoxyCodeLine{01087   dS.SetLength(nRow);      \textcolor{comment}{// (Posizione Target ) -\/ (posizione End effector)}}
\DoxyCodeLine{01088   dTheta.SetLength(nCol);  \textcolor{comment}{// Cambiamenti degli angoli dei Joints}}
\DoxyCodeLine{01089   dPreTheta.SetLength(nCol);}
\DoxyCodeLine{01090 }
\DoxyCodeLine{01091   \textcolor{comment}{// Usato nel: metodo del trasposto dello Jacobiano  \& DLS \& SDLS}}
\DoxyCodeLine{01092   dT.SetLength(nRow);}
\DoxyCodeLine{01093 }
\DoxyCodeLine{01094   \textcolor{comment}{// Usato nel Selectively Damped Least Squares Method}}
\DoxyCodeLine{01095   dSclamp.SetLength(nEffector);}
\DoxyCodeLine{01096 }
\DoxyCodeLine{01097   Jnorms.SetSize(nEffector, nCol);  \textcolor{comment}{// Memorizza le norme della matrice attiva J}}
\DoxyCodeLine{01098 }
\DoxyCodeLine{01099   DampingLambdaSqV.SetLength(nRow);}
\DoxyCodeLine{01100   diagMatIdentity.SetLength(nCol);}
\DoxyCodeLine{01101 }
\DoxyCodeLine{01102   Reset();}
\DoxyCodeLine{01103 \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_jacobian_a4e8a8e9abdcc9dfd6e47c13f533eb125}\label{class_jacobian_a4e8a8e9abdcc9dfd6e47c13f533eb125}} 
\index{Jacobian@{Jacobian}!addTarget@{addTarget}}
\index{addTarget@{addTarget}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{addTarget()}{addTarget()}}
{\footnotesize\ttfamily void Jacobian\+::add\+Target (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_t_point_t}{TPointD}}}]{target\+Pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00654 \{ target.push\_back(targetPos); \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_ad3ad85d7621c0bb7f986a4b89cb5872d}\label{class_jacobian_ad3ad85d7621c0bb7f986a4b89cb5872d}} 
\index{Jacobian@{Jacobian}!CalcDeltaThetasDLS@{CalcDeltaThetasDLS}}
\index{CalcDeltaThetasDLS@{CalcDeltaThetasDLS}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{CalcDeltaThetasDLS()}{CalcDeltaThetasDLS()}}
{\footnotesize\ttfamily void Jacobian\+::\+Calc\+Delta\+Thetas\+DLS (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01416                                   \{}
\DoxyCodeLine{01417   \textcolor{keyword}{const} \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} \&J = Jend;}
\DoxyCodeLine{01418 }
\DoxyCodeLine{01419   MatrixRmn::MultiplyTranspose(J, J, U);  \textcolor{comment}{// U = J * (J\string^T)}}
\DoxyCodeLine{01420 }
\DoxyCodeLine{01421   U.AddToDiagonal(DampingLambdaSqV);}
\DoxyCodeLine{01422 }
\DoxyCodeLine{01423   \textcolor{comment}{// Use the next four lines instead of the succeeding two lines for the DLS}}
\DoxyCodeLine{01424   \textcolor{comment}{// method with clamped error vector e.}}
\DoxyCodeLine{01425   \textcolor{comment}{// CalcdTClampedFromdS();}}
\DoxyCodeLine{01426   \textcolor{comment}{// VectorRn dTextra(2*nEffector);}}
\DoxyCodeLine{01427   \textcolor{comment}{// U.Solve( dT, \&dTextra );}}
\DoxyCodeLine{01428   \textcolor{comment}{// J.MultiplyTranspose( dTextra, dTheta );}}
\DoxyCodeLine{01429 }
\DoxyCodeLine{01430   \textcolor{comment}{// Use these two lines for the traditional DLS method}}
\DoxyCodeLine{01431   \textcolor{comment}{// gennaro}}
\DoxyCodeLine{01432 }
\DoxyCodeLine{01433   U.Solve(dS, \&dT);}
\DoxyCodeLine{01434   J.MultiplyTranspose(dT, dTheta);}
\DoxyCodeLine{01435 }
\DoxyCodeLine{01436   \textcolor{comment}{// Scalo per non superare l'nagolo massimod i cambiamento}}
\DoxyCodeLine{01437   \textcolor{keywordtype}{double} maxChange = 100 * dTheta.MaxAbs();}
\DoxyCodeLine{01438   \textcolor{keywordflow}{if} (maxChange > MaxAngleDLS) \{}
\DoxyCodeLine{01439     dTheta *= MaxAngleDLS / maxChange;}
\DoxyCodeLine{01440   \}}
\DoxyCodeLine{01441 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_ad56901602ef95216b0c294b8e619d2a2}\label{class_jacobian_ad56901602ef95216b0c294b8e619d2a2}} 
\index{Jacobian@{Jacobian}!CalcDeltaThetasDLSwithSVD@{CalcDeltaThetasDLSwithSVD}}
\index{CalcDeltaThetasDLSwithSVD@{CalcDeltaThetasDLSwithSVD}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{CalcDeltaThetasDLSwithSVD()}{CalcDeltaThetasDLSwithSVD()}}
{\footnotesize\ttfamily void Jacobian\+::\+Calc\+Delta\+Thetas\+DLSwith\+SVD (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01443                                          \{}
\DoxyCodeLine{01444   \textcolor{keyword}{const} \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} \&J = Jend;}
\DoxyCodeLine{01445 }
\DoxyCodeLine{01446   J.ComputeSVD(U, w, V);}
\DoxyCodeLine{01447 }
\DoxyCodeLine{01448   \textcolor{comment}{// For Debug}}
\DoxyCodeLine{01449   assert(J.DebugCheckSVD(U, w, V));}
\DoxyCodeLine{01450 }
\DoxyCodeLine{01451   \textcolor{comment}{// Calculate response vector dTheta that is the DLS solution.}}
\DoxyCodeLine{01452   \textcolor{comment}{//    Delta target values are the dS values}}
\DoxyCodeLine{01453   \textcolor{comment}{//  We multiply by DLS inverse of the J matrix}}
\DoxyCodeLine{01454   \textcolor{keywordtype}{long} diagLength = w.GetLength();}
\DoxyCodeLine{01455   \textcolor{keywordtype}{double} *wPtr    = w.GetPtr();}
\DoxyCodeLine{01456   dTheta.SetZero();}
\DoxyCodeLine{01457   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} i = 0; i < diagLength; i++) \{}
\DoxyCodeLine{01458     \textcolor{keywordtype}{double} dotProdCol =}
\DoxyCodeLine{01459         U.DotProductColumn(dS, i);  \textcolor{comment}{// Dot product with i-\/th column of U}}
\DoxyCodeLine{01460     \textcolor{keywordtype}{double} alpha = *(wPtr++);}
\DoxyCodeLine{01461     alpha        = alpha / (Square(alpha) + DampingLambdaSq);}
\DoxyCodeLine{01462     MatrixRmn::AddArrayScale(V.getNumRows(), V.GetColumnPtr(i), 1,}
\DoxyCodeLine{01463                              dTheta.GetPtr(), 1, dotProdCol * alpha);}
\DoxyCodeLine{01464   \}}
\DoxyCodeLine{01465 }
\DoxyCodeLine{01466   \textcolor{comment}{// Scale back to not exceed maximum angle changes}}
\DoxyCodeLine{01467   \textcolor{keywordtype}{double} maxChange = dTheta.MaxAbs();}
\DoxyCodeLine{01468   \textcolor{keywordflow}{if} (maxChange > MaxAngleDLS) \{}
\DoxyCodeLine{01469     dTheta *= MaxAngleDLS / maxChange;}
\DoxyCodeLine{01470   \}}
\DoxyCodeLine{01471 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_ad9bd2e44047605346ffd5987c43fe211}\label{class_jacobian_ad9bd2e44047605346ffd5987c43fe211}} 
\index{Jacobian@{Jacobian}!CalcDeltaThetasPseudoinverse@{CalcDeltaThetasPseudoinverse}}
\index{CalcDeltaThetasPseudoinverse@{CalcDeltaThetasPseudoinverse}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{CalcDeltaThetasPseudoinverse()}{CalcDeltaThetasPseudoinverse()}}
{\footnotesize\ttfamily void Jacobian\+::\+Calc\+Delta\+Thetas\+Pseudoinverse (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01236                                             \{}
\DoxyCodeLine{01237   \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} \&J = \textcolor{keyword}{const\_cast<}\mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} \&\textcolor{keyword}{>}(Jend);}
\DoxyCodeLine{01238 }
\DoxyCodeLine{01239   \textcolor{comment}{// costruisco matrice J1}}
\DoxyCodeLine{01240   \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} J1;}
\DoxyCodeLine{01241   J1.SetSize(2, J.getNumColumns());}
\DoxyCodeLine{01242 }
\DoxyCodeLine{01243   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; i++)}
\DoxyCodeLine{01244     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < J.getNumColumns(); j++) J1.Set(i, j, J.Get(i, j));}
\DoxyCodeLine{01245 }
\DoxyCodeLine{01246   \textcolor{comment}{// COSTRUISCO VETTORI ds1 e ds2}}
\DoxyCodeLine{01247   \mbox{\hyperlink{class_vector_rn}{VectorRn}} dS1(2);}
\DoxyCodeLine{01248 }
\DoxyCodeLine{01249   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; i++) dS1.Set(i, dS.Get(i));}
\DoxyCodeLine{01250 }
\DoxyCodeLine{01251   \textcolor{comment}{// calcolo dtheta1}}
\DoxyCodeLine{01252   \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} U, V;}
\DoxyCodeLine{01253   \mbox{\hyperlink{class_vector_rn}{VectorRn}} w;}
\DoxyCodeLine{01254 }
\DoxyCodeLine{01255   U.SetSize(J1.getNumRows(), J1.getNumRows());}
\DoxyCodeLine{01256   w.SetLength(min(J1.getNumRows(), J1.getNumColumns()));}
\DoxyCodeLine{01257   V.SetSize(J1.getNumColumns(), J1.getNumColumns());}
\DoxyCodeLine{01258 }
\DoxyCodeLine{01259   J1.ComputeSVD(U, w, V);}
\DoxyCodeLine{01260 }
\DoxyCodeLine{01261   \textcolor{comment}{// Next line for debugging only}}
\DoxyCodeLine{01262   assert(J1.DebugCheckSVD(U, w, V));}
\DoxyCodeLine{01263 }
\DoxyCodeLine{01264   \textcolor{comment}{// Calculate response vector dTheta that is the DLS solution.}}
\DoxyCodeLine{01265   \textcolor{comment}{//    Delta target values are the dS values}}
\DoxyCodeLine{01266   \textcolor{comment}{//  We multiply by Moore-\/Penrose pseudo-\/inverse of the J matrix}}
\DoxyCodeLine{01267 }
\DoxyCodeLine{01268   \textcolor{keywordtype}{double} pseudoInverseThreshold = PseudoInverseThresholdFactor * w.MaxAbs();}
\DoxyCodeLine{01269 }
\DoxyCodeLine{01270   \textcolor{keywordtype}{long} diagLength = w.GetLength();}
\DoxyCodeLine{01271   \textcolor{keywordtype}{double} *wPtr    = w.GetPtr();}
\DoxyCodeLine{01272   dTheta.SetZero();}
\DoxyCodeLine{01273   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} i = 0; i < diagLength; i++) \{}
\DoxyCodeLine{01274     \textcolor{keywordtype}{double} dotProdCol =}
\DoxyCodeLine{01275         U.DotProductColumn(dS1, i);  \textcolor{comment}{// Dot product with i-\/th column of U}}
\DoxyCodeLine{01276     \textcolor{keywordtype}{double} alpha = *(wPtr++);}
\DoxyCodeLine{01277     \textcolor{keywordflow}{if} (fabs(alpha) > pseudoInverseThreshold) \{}
\DoxyCodeLine{01278       alpha = 1.0 / alpha;}
\DoxyCodeLine{01279       MatrixRmn::AddArrayScale(V.getNumRows(), V.GetColumnPtr(i), 1,}
\DoxyCodeLine{01280                                dTheta.GetPtr(), 1, dotProdCol * alpha);}
\DoxyCodeLine{01281     \}}
\DoxyCodeLine{01282   \}}
\DoxyCodeLine{01283 }
\DoxyCodeLine{01284   \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} JcurrentPinv(V.getNumRows(),}
\DoxyCodeLine{01285                          J1.getNumRows());  \textcolor{comment}{// pseudoinversa di J1}}
\DoxyCodeLine{01286   \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} JProjPre(JcurrentPinv.getNumRows(),}
\DoxyCodeLine{01287                      J1.getNumColumns());  \textcolor{comment}{// Proiezione di J1}}
\DoxyCodeLine{01288   \textcolor{keywordflow}{if} (skeleton-\/>getNumEffector() > 1) \{}
\DoxyCodeLine{01289     \textcolor{comment}{// calcolo la pseudoinversa di J1}}
\DoxyCodeLine{01290     \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} VD(V.getNumRows(), J1.getNumRows());  \textcolor{comment}{// matrice del prodotto V*w}}
\DoxyCodeLine{01291 }
\DoxyCodeLine{01292     \textcolor{keywordtype}{double} *wPtr           = w.GetPtr();}
\DoxyCodeLine{01293     pseudoInverseThreshold = PseudoInverseThresholdFactor * w.MaxAbs();}
\DoxyCodeLine{01294     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < VD.getNumColumns(); j++) \{}
\DoxyCodeLine{01295       \textcolor{keywordtype}{double} *VPtr = V.GetColumnPtr(j);}
\DoxyCodeLine{01296       \textcolor{keywordtype}{double} alpha = *(wPtr++);  \textcolor{comment}{// elemento matrice diagonale}}
\DoxyCodeLine{01297       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < V.getNumRows(); i++) \{}
\DoxyCodeLine{01298         \textcolor{keywordflow}{if} (fabs(alpha) > pseudoInverseThreshold) \{}
\DoxyCodeLine{01299           \textcolor{keywordtype}{double} entry = *(VPtr++);}
\DoxyCodeLine{01300           VD.Set(i, j, entry * (1.0 / alpha));}
\DoxyCodeLine{01301         \}}
\DoxyCodeLine{01302       \}}
\DoxyCodeLine{01303     \}}
\DoxyCodeLine{01304     MatrixRmn::MultiplyTranspose(VD, U, JcurrentPinv);}
\DoxyCodeLine{01305 }
\DoxyCodeLine{01306     \textcolor{comment}{// calcolo la proiezione J1}}
\DoxyCodeLine{01307     MatrixRmn::Multiply(JcurrentPinv, J1, JProjPre);}
\DoxyCodeLine{01308 }
\DoxyCodeLine{01309     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < JProjPre.getNumColumns(); j++)}
\DoxyCodeLine{01310       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < JProjPre.getNumRows(); i++) \{}
\DoxyCodeLine{01311         \textcolor{keywordtype}{double} temp = JProjPre.Get(i, j);}
\DoxyCodeLine{01312         JProjPre.Set(i, j, -\/1.0 * temp);}
\DoxyCodeLine{01313       \}}
\DoxyCodeLine{01314     JProjPre.AddToDiagonal(diagMatIdentity);}
\DoxyCodeLine{01315   \}}
\DoxyCodeLine{01316 }
\DoxyCodeLine{01317   \textcolor{comment}{// task priority strategy}}
\DoxyCodeLine{01318   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < skeleton-\/>getNumEffector(); i++) \{}
\DoxyCodeLine{01319     \textcolor{comment}{// costruisco matrice Jcurrent (Ji)}}
\DoxyCodeLine{01320     \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} Jcurrent(2, J.getNumColumns());}
\DoxyCodeLine{01321     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < J.getNumColumns(); j++)}
\DoxyCodeLine{01322       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < 2; k++) Jcurrent.Set(k, j, J.Get(k + 2 * i, j));}
\DoxyCodeLine{01323 }
\DoxyCodeLine{01324     \textcolor{comment}{// costruisco il vettore dScurrent}}
\DoxyCodeLine{01325     \mbox{\hyperlink{class_vector_rn}{VectorRn}} dScurrent(2);}
\DoxyCodeLine{01326     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < 2; k++) dScurrent.Set(k, dS.Get(k + 2 * i));}
\DoxyCodeLine{01327 }
\DoxyCodeLine{01328     \textcolor{comment}{// Moltiplico Jcurrent per la proiezione di J(i-\/1)}}
\DoxyCodeLine{01329     \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} Jdst(Jcurrent.getNumRows(), JProjPre.getNumColumns());}
\DoxyCodeLine{01330     MatrixRmn::Multiply(Jcurrent, JProjPre, Jdst);}
\DoxyCodeLine{01331 }
\DoxyCodeLine{01332     \textcolor{comment}{// Calcolo la pseudoinversa di Jdst}}
\DoxyCodeLine{01333     \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} UU(Jdst.getNumRows(), Jdst.getNumRows()),}
\DoxyCodeLine{01334         VV(Jdst.getNumColumns(), Jdst.getNumColumns());}
\DoxyCodeLine{01335     \mbox{\hyperlink{class_vector_rn}{VectorRn}} ww(min(Jdst.getNumRows(), Jdst.getNumColumns()));}
\DoxyCodeLine{01336 }
\DoxyCodeLine{01337     Jdst.ComputeSVD(UU, ww, VV);}
\DoxyCodeLine{01338     assert(Jdst.DebugCheckSVD(UU, ww, VV));}
\DoxyCodeLine{01339 }
\DoxyCodeLine{01340     \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} VVD(VV.getNumRows(), J1.getNumRows());  \textcolor{comment}{// matrice V*w}}
\DoxyCodeLine{01341     VVD.SetZero();}
\DoxyCodeLine{01342     pseudoInverseThreshold = PseudoInverseThresholdFactor * ww.MaxAbs();}
\DoxyCodeLine{01343     \textcolor{keywordtype}{double} *wwPtr          = ww.GetPtr();}
\DoxyCodeLine{01344     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < VVD.getNumColumns(); j++) \{}
\DoxyCodeLine{01345       \textcolor{keywordtype}{double} *VVPtr = VV.GetColumnPtr(j);}
\DoxyCodeLine{01346       \textcolor{keywordtype}{double} alpha  = 50 * (*(wwPtr++));  \textcolor{comment}{// elemento matrice diagonale}}
\DoxyCodeLine{01347       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < VV.getNumRows(); i++) \{}
\DoxyCodeLine{01348         \textcolor{keywordflow}{if} (fabs(alpha) > 100 * pseudoInverseThreshold) \{}
\DoxyCodeLine{01349           \textcolor{keywordtype}{double} entry = *(VVPtr++);}
\DoxyCodeLine{01350           VVD.Set(i, j, entry * (1.0 / alpha));}
\DoxyCodeLine{01351         \}}
\DoxyCodeLine{01352       \}}
\DoxyCodeLine{01353     \}}
\DoxyCodeLine{01354     \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} JdstPinv(VV.getNumRows(), J1.getNumRows());}
\DoxyCodeLine{01355     MatrixRmn::MultiplyTranspose(VVD, UU, JdstPinv);}
\DoxyCodeLine{01356 }
\DoxyCodeLine{01357     \mbox{\hyperlink{class_vector_rn}{VectorRn}} dTemp(J1.getNumRows());}
\DoxyCodeLine{01358     Jcurrent.Multiply(dTheta, dTemp);}
\DoxyCodeLine{01359 }
\DoxyCodeLine{01360     \mbox{\hyperlink{class_vector_rn}{VectorRn}} dTemp2(dScurrent.GetLength());}
\DoxyCodeLine{01361     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k  = 0; k < dScurrent.GetLength(); k++)}
\DoxyCodeLine{01362       dTemp2[k] = dScurrent[k] -\/ dTemp[k];}
\DoxyCodeLine{01363 }
\DoxyCodeLine{01364     \textcolor{comment}{// Moltiplico JdstPinv per dTemp2}}
\DoxyCodeLine{01365     \mbox{\hyperlink{class_vector_rn}{VectorRn}} dThetaCurrent(JdstPinv.getNumRows());}
\DoxyCodeLine{01366     JdstPinv.Multiply(dTemp2, dThetaCurrent);}
\DoxyCodeLine{01367     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < dTheta.GetLength(); k++) dTheta[k] += dThetaCurrent[k];}
\DoxyCodeLine{01368 }
\DoxyCodeLine{01369     \textcolor{comment}{// Infine mi calcolo la pseudoinversa di Jcurrent e quindi la sua proiezione}}
\DoxyCodeLine{01370     \textcolor{comment}{// che servirà al passo successivo}}
\DoxyCodeLine{01371 }
\DoxyCodeLine{01372     \textcolor{comment}{// calcolo la pseudoinversa di Jcurrent}}
\DoxyCodeLine{01373     Jcurrent.ComputeSVD(U, w, V);}
\DoxyCodeLine{01374     assert(Jcurrent.DebugCheckSVD(U, w, V));}
\DoxyCodeLine{01375 }
\DoxyCodeLine{01376     \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} VD(V.getNumRows(),}
\DoxyCodeLine{01377                  Jcurrent.getNumRows());  \textcolor{comment}{// matrice del prodotto V*w}}
\DoxyCodeLine{01378 }
\DoxyCodeLine{01379     \textcolor{keywordtype}{double} *wPtr           = w.GetPtr();}
\DoxyCodeLine{01380     pseudoInverseThreshold = PseudoInverseThresholdFactor * w.MaxAbs();}
\DoxyCodeLine{01381     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < VVD.getNumColumns(); j++) \{}
\DoxyCodeLine{01382       \textcolor{keywordtype}{double} *VPtr = V.GetColumnPtr(j);}
\DoxyCodeLine{01383       \textcolor{keywordtype}{double} alpha = *(wPtr++);  \textcolor{comment}{// elemento matrice diagonale}}
\DoxyCodeLine{01384       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < V.getNumRows(); i++) \{}
\DoxyCodeLine{01385         \textcolor{keywordflow}{if} (fabs(alpha) > pseudoInverseThreshold) \{}
\DoxyCodeLine{01386           \textcolor{keywordtype}{double} entry = *(VPtr++);}
\DoxyCodeLine{01387           VD.Set(i, j, entry * (1.0 / alpha));}
\DoxyCodeLine{01388         \}}
\DoxyCodeLine{01389       \}}
\DoxyCodeLine{01390     \}}
\DoxyCodeLine{01391     MatrixRmn::MultiplyTranspose(VD, U, JcurrentPinv);}
\DoxyCodeLine{01392 }
\DoxyCodeLine{01393     \textcolor{comment}{// calcolo la proiezione Jcurrent}}
\DoxyCodeLine{01394     MatrixRmn::Multiply(JcurrentPinv, Jcurrent, JProjPre);}
\DoxyCodeLine{01395 }
\DoxyCodeLine{01396     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < JProjPre.getNumColumns(); j++)}
\DoxyCodeLine{01397       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < JProjPre.getNumRows(); k++) \{}
\DoxyCodeLine{01398         \textcolor{keywordtype}{double} temp = JProjPre.Get(k, j);}
\DoxyCodeLine{01399         JProjPre.Set(k, j, -\/1.0 * temp);}
\DoxyCodeLine{01400       \}}
\DoxyCodeLine{01401     JProjPre.AddToDiagonal(diagMatIdentity);}
\DoxyCodeLine{01402   \}}
\DoxyCodeLine{01403 }
\DoxyCodeLine{01404   \textcolor{comment}{// sw.stop();}}
\DoxyCodeLine{01405   \textcolor{comment}{// std::ofstream os("{}C:\(\backslash\)\(\backslash\)buttami.txt"{}, std::ios::app);}}
\DoxyCodeLine{01406   \textcolor{comment}{// sw.print(os);}}
\DoxyCodeLine{01407   \textcolor{comment}{// os.close();}}
\DoxyCodeLine{01408 }
\DoxyCodeLine{01409   \textcolor{comment}{// Scale back to not exceed maximum angle changes}}
\DoxyCodeLine{01410   \textcolor{keywordtype}{double} maxChange = 10 * dTheta.MaxAbs();}
\DoxyCodeLine{01411   \textcolor{keywordflow}{if} (maxChange > MaxAnglePseudoinverse) \{}
\DoxyCodeLine{01412     dTheta *= MaxAnglePseudoinverse / maxChange;}
\DoxyCodeLine{01413   \}}
\DoxyCodeLine{01414 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_ad4a0f0bf23ec7caaacd33181248a4762}\label{class_jacobian_ad4a0f0bf23ec7caaacd33181248a4762}} 
\index{Jacobian@{Jacobian}!CalcDeltaThetasSDLS@{CalcDeltaThetasSDLS}}
\index{CalcDeltaThetasSDLS@{CalcDeltaThetasSDLS}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{CalcDeltaThetasSDLS()}{CalcDeltaThetasSDLS()}}
{\footnotesize\ttfamily void Jacobian\+::\+Calc\+Delta\+Thetas\+SDLS (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01473                                    \{}
\DoxyCodeLine{01474   \textcolor{keyword}{const} \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} \&J = Jend;}
\DoxyCodeLine{01475 }
\DoxyCodeLine{01476   \textcolor{comment}{// Compute Singular Value Decomposition}}
\DoxyCodeLine{01477 }
\DoxyCodeLine{01478   J.ComputeSVD(U, w, V);}
\DoxyCodeLine{01479 }
\DoxyCodeLine{01480   \textcolor{comment}{// Next line for debugging only}}
\DoxyCodeLine{01481   assert(J.DebugCheckSVD(U, w, V));}
\DoxyCodeLine{01482 }
\DoxyCodeLine{01483   \textcolor{comment}{// Calculate response vector dTheta that is the SDLS solution.}}
\DoxyCodeLine{01484   \textcolor{comment}{//    Delta target values are the dS values}}
\DoxyCodeLine{01485   \textcolor{keywordtype}{int} nRows           = J.getNumRows();}
\DoxyCodeLine{01486   \textcolor{keywordtype}{int} numEndEffectors = skeleton-\/>getNumEffector();  \textcolor{comment}{// Equals the number of}}
\DoxyCodeLine{01487                                                      \textcolor{comment}{// rows of J divided by}}
\DoxyCodeLine{01488                                                      \textcolor{comment}{// three}}
\DoxyCodeLine{01489   \textcolor{keywordtype}{int} nCols = J.getNumColumns();}
\DoxyCodeLine{01490   dTheta.SetZero();}
\DoxyCodeLine{01491 }
\DoxyCodeLine{01492   \textcolor{comment}{// Calculate the norms of the 3-\/vectors in the Jacobian}}
\DoxyCodeLine{01493   \textcolor{keywordtype}{long} i;}
\DoxyCodeLine{01494   \textcolor{keyword}{const} \textcolor{keywordtype}{double} *jx = J.GetPtr();}
\DoxyCodeLine{01495   \textcolor{keywordtype}{double} *jnx      = Jnorms.GetPtr();}
\DoxyCodeLine{01496   \textcolor{keywordflow}{for} (i = nCols * numEndEffectors; i > 0; i-\/-\/) \{}
\DoxyCodeLine{01497     \textcolor{keywordtype}{double} accumSq = Square(*(jx++));}
\DoxyCodeLine{01498     accumSq += Square(*(jx++));}
\DoxyCodeLine{01499     accumSq += Square(*(jx++));}
\DoxyCodeLine{01500     *(jnx++) = sqrt(accumSq);}
\DoxyCodeLine{01501   \}}
\DoxyCodeLine{01502 }
\DoxyCodeLine{01503   \textcolor{comment}{// Clamp the dS values}}
\DoxyCodeLine{01504   CalcdTClampedFromdS();}
\DoxyCodeLine{01505 }
\DoxyCodeLine{01506   \textcolor{comment}{// Loop over each singular vector}}
\DoxyCodeLine{01507   \textcolor{keywordflow}{for} (i = 0; i < nRows; i++) \{}
\DoxyCodeLine{01508     \textcolor{keywordtype}{double} wiInv = w[i];}
\DoxyCodeLine{01509     \textcolor{keywordflow}{if} (NearZero(wiInv, 1.0e-\/10)) \{}
\DoxyCodeLine{01510       \textcolor{keywordflow}{continue};}
\DoxyCodeLine{01511     \}}
\DoxyCodeLine{01512     wiInv = 1.0 / wiInv;}
\DoxyCodeLine{01513 }
\DoxyCodeLine{01514     \textcolor{keywordtype}{double} N = 0.0;  \textcolor{comment}{// N is the quasi-\/1-\/norm of the i-\/th column of U}}
\DoxyCodeLine{01515     \textcolor{keywordtype}{double} alpha =}
\DoxyCodeLine{01516         0.0;  \textcolor{comment}{// alpha is the dot product of dT and the i-\/th column of U}}
\DoxyCodeLine{01517 }
\DoxyCodeLine{01518     \textcolor{keyword}{const} \textcolor{keywordtype}{double} *dTx = dT.GetPtr();}
\DoxyCodeLine{01519     \textcolor{keyword}{const} \textcolor{keywordtype}{double} *ux  = U.GetColumnPtr(i);}
\DoxyCodeLine{01520     \textcolor{keywordtype}{long} j;}
\DoxyCodeLine{01521     \textcolor{keywordflow}{for} (j = numEndEffectors; j > 0; j-\/-\/) \{}
\DoxyCodeLine{01522       \textcolor{keywordtype}{double} tmp;}
\DoxyCodeLine{01523       alpha += (*ux) * (*(dTx++));}
\DoxyCodeLine{01524       tmp = Square(*(ux++));}
\DoxyCodeLine{01525       alpha += (*ux) * (*(dTx++));}
\DoxyCodeLine{01526       tmp += Square(*(ux++));}
\DoxyCodeLine{01527       alpha += (*ux) * (*(dTx++));}
\DoxyCodeLine{01528       tmp += Square(*(ux++));}
\DoxyCodeLine{01529       N += sqrt(tmp);}
\DoxyCodeLine{01530     \}}
\DoxyCodeLine{01531 }
\DoxyCodeLine{01532     \textcolor{comment}{// M is the quasi-\/1-\/norm of the response to angles changing according to the}}
\DoxyCodeLine{01533     \textcolor{comment}{// i-\/th column of V}}
\DoxyCodeLine{01534     \textcolor{comment}{//      Then is multiplied by the wiInv value.}}
\DoxyCodeLine{01535     \textcolor{keywordtype}{double} M   = 0.0;}
\DoxyCodeLine{01536     \textcolor{keywordtype}{double} *vx = V.GetColumnPtr(i);}
\DoxyCodeLine{01537     jnx        = Jnorms.GetPtr();}
\DoxyCodeLine{01538     \textcolor{keywordflow}{for} (j = nCols; j > 0; j-\/-\/) \{}
\DoxyCodeLine{01539       \textcolor{keywordtype}{double} accum = 0.0;}
\DoxyCodeLine{01540       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{long} k = numEndEffectors; k > 0; k-\/-\/) \{}
\DoxyCodeLine{01541         accum += *(jnx++);}
\DoxyCodeLine{01542       \}}
\DoxyCodeLine{01543       M += fabs((*(vx++))) * accum;}
\DoxyCodeLine{01544     \}}
\DoxyCodeLine{01545     M *= fabs(wiInv);}
\DoxyCodeLine{01546 }
\DoxyCodeLine{01547     \textcolor{keywordtype}{double} gamma = MaxAngleSDLS;}
\DoxyCodeLine{01548     \textcolor{keywordflow}{if} (N < M) \{}
\DoxyCodeLine{01549       gamma *= N / M;  \textcolor{comment}{// Scale back maximum permissible joint angle}}
\DoxyCodeLine{01550     \}}
\DoxyCodeLine{01551 }
\DoxyCodeLine{01552     \textcolor{comment}{// Calculate the dTheta from pure pseudoinverse considerations}}
\DoxyCodeLine{01553     \textcolor{keywordtype}{double} scale =}
\DoxyCodeLine{01554         alpha *}
\DoxyCodeLine{01555         wiInv;  \textcolor{comment}{// This times i-\/th column of V is the pseudoinverse response}}
\DoxyCodeLine{01556     dPreTheta.LoadScaled(V.GetColumnPtr(i), scale);}
\DoxyCodeLine{01557     \textcolor{comment}{// Now rescale the dTheta values.}}
\DoxyCodeLine{01558     \textcolor{keywordtype}{double} max     = dPreTheta.MaxAbs();}
\DoxyCodeLine{01559     \textcolor{keywordtype}{double} rescale = (gamma) / (gamma + max);}
\DoxyCodeLine{01560     dTheta.AddScaled(dPreTheta, rescale);}
\DoxyCodeLine{01561     \textcolor{comment}{/*if ( gamma<max) \{}}
\DoxyCodeLine{01562 \textcolor{comment}{            dTheta.AddScaled( dPreTheta, gamma/max );}}
\DoxyCodeLine{01563 \textcolor{comment}{    \}}}
\DoxyCodeLine{01564 \textcolor{comment}{    else \{}}
\DoxyCodeLine{01565 \textcolor{comment}{            dTheta += dPreTheta;}}
\DoxyCodeLine{01566 \textcolor{comment}{    \}*/}}
\DoxyCodeLine{01567   \}}
\DoxyCodeLine{01568 }
\DoxyCodeLine{01569   \textcolor{comment}{// Scale back to not exceed maximum angle changes}}
\DoxyCodeLine{01570   \textcolor{keywordtype}{double} maxChange = dTheta.MaxAbs();}
\DoxyCodeLine{01571   \textcolor{keywordflow}{if} (maxChange > 100 * MaxAngleSDLS) \{}
\DoxyCodeLine{01572     dTheta *= MaxAngleSDLS / (MaxAngleSDLS + maxChange);}
\DoxyCodeLine{01573     \textcolor{comment}{// dTheta *= MaxAngleSDLS/maxChange;}}
\DoxyCodeLine{01574   \}}
\DoxyCodeLine{01575 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_a0bb9b42c4eea995050f0c835aaeabcd1}\label{class_jacobian_a0bb9b42c4eea995050f0c835aaeabcd1}} 
\index{Jacobian@{Jacobian}!CalcDeltaThetasTranspose@{CalcDeltaThetasTranspose}}
\index{CalcDeltaThetasTranspose@{CalcDeltaThetasTranspose}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{CalcDeltaThetasTranspose()}{CalcDeltaThetasTranspose()}}
{\footnotesize\ttfamily void Jacobian\+::\+Calc\+Delta\+Thetas\+Transpose (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01221                                         \{}
\DoxyCodeLine{01222   \textcolor{keyword}{const} \mbox{\hyperlink{class_matrix_rmn}{MatrixRmn}} \&J = Jend;}
\DoxyCodeLine{01223 }
\DoxyCodeLine{01224   J.MultiplyTranspose(dS, dTheta);}
\DoxyCodeLine{01225 }
\DoxyCodeLine{01226   \textcolor{comment}{// Scale back the dTheta values greedily}}
\DoxyCodeLine{01227   J.Multiply(dTheta, dT);  \textcolor{comment}{// dT = J * dTheta}}
\DoxyCodeLine{01228   \textcolor{keywordtype}{double} alpha = Dot(dS, dT) / dT.NormSq();}
\DoxyCodeLine{01229   assert(alpha > 0.0);}
\DoxyCodeLine{01230   \textcolor{comment}{// Also scale back to be have max angle change less than MaxAngleJtranspose}}
\DoxyCodeLine{01231   \textcolor{keywordtype}{double} maxChange = dTheta.MaxAbs();}
\DoxyCodeLine{01232   \textcolor{keywordtype}{double} beta      = MaxAngleJtranspose / maxChange;}
\DoxyCodeLine{01233   dTheta *= min(alpha, beta);}
\DoxyCodeLine{01234 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_aeabf2c921517d3f7f313701399e95b59}\label{class_jacobian_aeabf2c921517d3f7f313701399e95b59}} 
\index{Jacobian@{Jacobian}!checkJointsLimit@{checkJointsLimit}}
\index{checkJointsLimit@{checkJointsLimit}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{checkJointsLimit()}{checkJointsLimit()}}
{\footnotesize\ttfamily bool Jacobian\+::check\+Joints\+Limit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01191                                 \{}
\DoxyCodeLine{01192   \textcolor{keywordtype}{bool} clampingDetected = \textcolor{keyword}{false};}
\DoxyCodeLine{01193   \textcolor{comment}{/*}}
\DoxyCodeLine{01194 \textcolor{comment}{  Node* n = skeleton-\/>getNode(3);}}
\DoxyCodeLine{01195 \textcolor{comment}{  int indexJoint = n-\/>getJointNum();}}
\DoxyCodeLine{01196 \textcolor{comment}{  double theta = n-\/>getTheta();}}
\DoxyCodeLine{01197 \textcolor{comment}{  double upperLimit = PI;}}
\DoxyCodeLine{01198 \textcolor{comment}{  double lowerLimit = 0.0;}}
\DoxyCodeLine{01199 \textcolor{comment}{  if(theta >upperLimit || theta <lowerLimit)}}
\DoxyCodeLine{01200 \textcolor{comment}{  \{}}
\DoxyCodeLine{01201 \textcolor{comment}{          if(theta<upperLimit)  upperLimit = lowerLimit;}}
\DoxyCodeLine{01202 \textcolor{comment}{          clampingDetected = true;}}
\DoxyCodeLine{01203 \textcolor{comment}{          double clampingVar = theta -\/ upperLimit;}}
\DoxyCodeLine{01204 \textcolor{comment}{          for(int i=0;i<Jactive-\/>getNumRows();i++)}}
\DoxyCodeLine{01205 \textcolor{comment}{          \{}}
\DoxyCodeLine{01206 \textcolor{comment}{                  double tmp = clampingVar*Jactive-\/>Get(i,indexJoint);}}
\DoxyCodeLine{01207 \textcolor{comment}{                  dS[i] -\/= tmp;}}
\DoxyCodeLine{01208 \textcolor{comment}{                  Jactive-\/>Set(i,indexJoint,0.0);}}
\DoxyCodeLine{01209 \textcolor{comment}{          \}}}
\DoxyCodeLine{01210 \textcolor{comment}{          n-\/>setTheta(upperLimit);}}
\DoxyCodeLine{01211 \textcolor{comment}{          diagMatIdentity.Set(indexJoint, 0.0);}}
\DoxyCodeLine{01212 \textcolor{comment}{}}
\DoxyCodeLine{01213 \textcolor{comment}{  \}*/}}
\DoxyCodeLine{01214   \textcolor{keywordflow}{return} clampingDetected;}
\DoxyCodeLine{01215 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_aa661382ab1057f0663a40d1d73127ad8}\label{class_jacobian_aa661382ab1057f0663a40d1d73127ad8}} 
\index{Jacobian@{Jacobian}!computeJacobian@{computeJacobian}}
\index{computeJacobian@{computeJacobian}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{computeJacobian()}{computeJacobian()}}
{\footnotesize\ttfamily void Jacobian\+::compute\+Jacobian (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01120                                \{}
\DoxyCodeLine{01121   \textcolor{comment}{// Scorro tutto lo skeleton per trovare tutti gli end effectors}}
\DoxyCodeLine{01122 }
\DoxyCodeLine{01123   \textcolor{keywordtype}{int} numNode = skeleton-\/>getNodeCount();}
\DoxyCodeLine{01124   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} index = 0; index < numNode; index++) \{}
\DoxyCodeLine{01125     \mbox{\hyperlink{class_i_k_node}{IKNode}} *n         = skeleton-\/>getNode(index);}
\DoxyCodeLine{01126     \textcolor{keywordtype}{int} effectorCount = skeleton-\/>getNumEffector();}
\DoxyCodeLine{01127     \textcolor{keywordflow}{if} (n-\/>IsEffector()) \{}
\DoxyCodeLine{01128       \textcolor{keywordtype}{int} i                    = n-\/>getEffectorNum();}
\DoxyCodeLine{01129       \textcolor{keyword}{const} \mbox{\hyperlink{class_t_point_t}{TPointD}} \&targetPos = target[i];}
\DoxyCodeLine{01130       \mbox{\hyperlink{class_t_point_t}{TPointD}} temp;}
\DoxyCodeLine{01131       \textcolor{comment}{// Calcolo i valori di deltaS (differenza tra end effectors e target}}
\DoxyCodeLine{01132       \textcolor{comment}{// positions.)}}
\DoxyCodeLine{01133       temp      = targetPos;}
\DoxyCodeLine{01134       \mbox{\hyperlink{class_t_point_t}{TPointD}} a = n-\/>GetS();}
\DoxyCodeLine{01135       temp -\/= n-\/>GetS();}
\DoxyCodeLine{01136       \textcolor{keywordflow}{if} (i < effectorCount -\/ 1) \{}
\DoxyCodeLine{01137         temp.x = 100 * temp.x;}
\DoxyCodeLine{01138         temp.y = 100 * temp.y;}
\DoxyCodeLine{01139       \}}
\DoxyCodeLine{01140       dS.SetCouple(i, temp);}
\DoxyCodeLine{01141 }
\DoxyCodeLine{01142       \textcolor{comment}{// Find all ancestors (they will usually all be joints)}}
\DoxyCodeLine{01143       \textcolor{comment}{// Set the corresponding entries in the Jacobians J, K.}}
\DoxyCodeLine{01144       \mbox{\hyperlink{class_i_k_node}{IKNode}} *m = skeleton-\/>getParent(n);}
\DoxyCodeLine{01145 }
\DoxyCodeLine{01146       \textcolor{keywordflow}{while} (m) \{}
\DoxyCodeLine{01147         \textcolor{keywordtype}{int} j = m-\/>getJointNum();}
\DoxyCodeLine{01148         \textcolor{comment}{// assert(j>=0 \&\& j<skeleton-\/>GetNumJoint());}}
\DoxyCodeLine{01149         \textcolor{keywordtype}{int} numnode = skeleton-\/>getNodeCount();}
\DoxyCodeLine{01150         assert(0 <= i \&\& i < nEffector \&\& 0 <= j \&\&}
\DoxyCodeLine{01151                j < (skeleton-\/>getNodeCount() -\/ skeleton-\/>getNumEffector()));}
\DoxyCodeLine{01152         \textcolor{keywordflow}{if} (m-\/>isFrozen()) \{}
\DoxyCodeLine{01153           Jend.SetCouple(i, j, \mbox{\hyperlink{class_t_point_t}{TPointD}}(0.0, 0.0));}
\DoxyCodeLine{01154 }
\DoxyCodeLine{01155         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{01156           temp = m-\/>GetS();   \textcolor{comment}{// joint pos.}}
\DoxyCodeLine{01157           temp -\/= n-\/>GetS();  \textcolor{comment}{// -\/(end effector pos. -\/ joint pos.)}}
\DoxyCodeLine{01158 }
\DoxyCodeLine{01159           \textcolor{keywordtype}{double} tx = temp.x;}
\DoxyCodeLine{01160           temp.x    = temp.y;}
\DoxyCodeLine{01161           temp.y    = -\/tx;}
\DoxyCodeLine{01162 }
\DoxyCodeLine{01163           \textcolor{keywordflow}{if} (i < effectorCount -\/ 1) \{}
\DoxyCodeLine{01164             temp.x = 100 * temp.x;}
\DoxyCodeLine{01165             temp.y = 100 * temp.y;}
\DoxyCodeLine{01166           \}}
\DoxyCodeLine{01167           Jend.SetCouple(i, j, temp);}
\DoxyCodeLine{01168         \}}
\DoxyCodeLine{01169         m = skeleton-\/>getParent(m);}
\DoxyCodeLine{01170       \}}
\DoxyCodeLine{01171     \}}
\DoxyCodeLine{01172   \}}
\DoxyCodeLine{01173 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_a93f20df15d29f76884323ac738efd3d4}\label{class_jacobian_a93f20df15d29f76884323ac738efd3d4}} 
\index{Jacobian@{Jacobian}!deletLastTarget@{deletLastTarget}}
\index{deletLastTarget@{deletLastTarget}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{deletLastTarget()}{deletLastTarget()}}
{\footnotesize\ttfamily void Jacobian\+::delet\+Last\+Target (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00655 \{ target.pop\_back(); \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_a5a2be3c1b9bdfca91fd0c6bbdb152558}\label{class_jacobian_a5a2be3c1b9bdfca91fd0c6bbdb152558}} 
\index{Jacobian@{Jacobian}!GetCurrentMode@{GetCurrentMode}}
\index{GetCurrentMode@{GetCurrentMode}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{GetCurrentMode()}{GetCurrentMode()}}
{\footnotesize\ttfamily Update\+Mode Jacobian\+::\+Get\+Current\+Mode (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00672 \{ \textcolor{keywordflow}{return} CurrentUpdateMode; \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_a63640e5c70a253f167e235ccbdaec132}\label{class_jacobian_a63640e5c70a253f167e235ccbdaec132}} 
\index{Jacobian@{Jacobian}!Reset@{Reset}}
\index{Reset@{Reset}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{Reset()}{Reset()}}
{\footnotesize\ttfamily void Jacobian\+::\+Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01105                      \{}
\DoxyCodeLine{01106   \textcolor{comment}{// Usato nel Damped Least Squares Method}}
\DoxyCodeLine{01107   DampingLambda   = DefaultDampingLambda;}
\DoxyCodeLine{01108   DampingLambdaSq = Square(DampingLambda);}
\DoxyCodeLine{01109   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i            = 0; i < DampingLambdaSqV.GetLength(); i++)}
\DoxyCodeLine{01110     DampingLambdaSqV[i] = DampingLambdaSq;}
\DoxyCodeLine{01111   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i           = 0; i < diagMatIdentity.GetLength(); i++)}
\DoxyCodeLine{01112     diagMatIdentity[i] = 1.0;}
\DoxyCodeLine{01113   \textcolor{comment}{// DampingLambdaSDLS = 1.5*DefaultDampingLambda;}}
\DoxyCodeLine{01114 }
\DoxyCodeLine{01115   dSclamp.Fill(HUGE\_VAL);}
\DoxyCodeLine{01116 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_a61c48f4ac57b20c0b007dde2d8f6038c}\label{class_jacobian_a61c48f4ac57b20c0b007dde2d8f6038c}} 
\index{Jacobian@{Jacobian}!SetCurrentMode@{SetCurrentMode}}
\index{SetCurrentMode@{SetCurrentMode}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{SetCurrentMode()}{SetCurrentMode()}}
{\footnotesize\ttfamily void Jacobian\+::\+Set\+Current\+Mode (\begin{DoxyParamCaption}\item[{Update\+Mode}]{mode }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00671 \{ CurrentUpdateMode = mode; \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_ad8fb54d90eb0fe47b0a1818f6818288f}\label{class_jacobian_ad8fb54d90eb0fe47b0a1818f6818288f}} 
\index{Jacobian@{Jacobian}!SetDampingDLS@{SetDampingDLS}}
\index{SetDampingDLS@{SetDampingDLS}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{SetDampingDLS()}{SetDampingDLS()}}
{\footnotesize\ttfamily void Jacobian\+::\+Set\+Damping\+DLS (\begin{DoxyParamCaption}\item[{double}]{lambda }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00673                                     \{}
\DoxyCodeLine{00674     DampingLambda   = lambda;}
\DoxyCodeLine{00675     DampingLambdaSq = lambda * lambda;}
\DoxyCodeLine{00676   \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_a24eeaefbe56036da7af4a77e66f7891c}\label{class_jacobian_a24eeaefbe56036da7af4a77e66f7891c}} 
\index{Jacobian@{Jacobian}!setTarget@{setTarget}}
\index{setTarget@{setTarget}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{setTarget()}{setTarget()}}
{\footnotesize\ttfamily void Jacobian\+::set\+Target (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{\mbox{\hyperlink{class_t_point_t}{TPointD}}}]{target\+Pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00656 \{ target[i] = targetPos; \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_a30a78448bc6bfa73d9c06a149bb9ff9e}\label{class_jacobian_a30a78448bc6bfa73d9c06a149bb9ff9e}} 
\index{Jacobian@{Jacobian}!UpdatedSClampValue@{UpdatedSClampValue}}
\index{UpdatedSClampValue@{UpdatedSClampValue}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{UpdatedSClampValue()}{UpdatedSClampValue()}}
{\footnotesize\ttfamily void Jacobian\+::\+Updated\+SClamp\+Value (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01595                                   \{}
\DoxyCodeLine{01596   \textcolor{comment}{// Traverse skeleton to find all end effectors}}
\DoxyCodeLine{01597   \mbox{\hyperlink{class_t_point_t}{TPointD}} temp;}
\DoxyCodeLine{01598 }
\DoxyCodeLine{01599   \textcolor{keywordtype}{int} numNode = skeleton-\/>getNodeCount();}
\DoxyCodeLine{01600   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < numNode; i++) \{}
\DoxyCodeLine{01601     \mbox{\hyperlink{class_i_k_node}{IKNode}} *n = skeleton-\/>getNode(i);}
\DoxyCodeLine{01602     \textcolor{keywordflow}{if} (n-\/>IsEffector()) \{}
\DoxyCodeLine{01603       \textcolor{keywordtype}{int} i                    = n-\/>getEffectorNum();}
\DoxyCodeLine{01604       \textcolor{keyword}{const} \mbox{\hyperlink{class_t_point_t}{TPointD}} \&targetPos = target[i];}
\DoxyCodeLine{01605 }
\DoxyCodeLine{01606       \textcolor{comment}{// Compute the delta S value (differences from end effectors to target}}
\DoxyCodeLine{01607       \textcolor{comment}{// positions.}}
\DoxyCodeLine{01608       \textcolor{comment}{// While we are at it, also update the clamping values in dSclamp;}}
\DoxyCodeLine{01609       temp = targetPos;}
\DoxyCodeLine{01610       temp -\/= n-\/>GetS();}
\DoxyCodeLine{01611       \textcolor{keywordtype}{double} normSi      = sqrt(Square(dS[i]) + Square(dS[i + 1]));}
\DoxyCodeLine{01612       \textcolor{keywordtype}{double} norma       = sqrt(temp.x * temp.x + temp.y * temp.y);}
\DoxyCodeLine{01613       \textcolor{keywordtype}{double} changedDist = norma -\/ normSi;}
\DoxyCodeLine{01614 }
\DoxyCodeLine{01615       \textcolor{keywordflow}{if} (changedDist > 0.0) \{}
\DoxyCodeLine{01616         dSclamp[i] = BaseMaxTargetDist + changedDist;}
\DoxyCodeLine{01617       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{01618         dSclamp[i] = BaseMaxTargetDist;}
\DoxyCodeLine{01619       \}}
\DoxyCodeLine{01620     \}}
\DoxyCodeLine{01621   \}}
\DoxyCodeLine{01622 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_abb9b64db63ca485a053724d9b251a4dc}\label{class_jacobian_abb9b64db63ca485a053724d9b251a4dc}} 
\index{Jacobian@{Jacobian}!UpdateThetas@{UpdateThetas}}
\index{UpdateThetas@{UpdateThetas}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{UpdateThetas()}{UpdateThetas()}}
{\footnotesize\ttfamily void Jacobian\+::\+Update\+Thetas (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01178                             \{}
\DoxyCodeLine{01179   \textcolor{comment}{// Update the joint angles}}
\DoxyCodeLine{01180   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} index = 0; index < skeleton-\/>getNodeCount(); index++) \{}
\DoxyCodeLine{01181     \mbox{\hyperlink{class_i_k_node}{IKNode}} *n = skeleton-\/>getNode(index);}
\DoxyCodeLine{01182     \textcolor{keywordflow}{if} (n-\/>IsJoint()) \{}
\DoxyCodeLine{01183       \textcolor{keywordtype}{int} i = n-\/>getJointNum();}
\DoxyCodeLine{01184       n-\/>AddToTheta(dTheta[i]);}
\DoxyCodeLine{01185     \}}
\DoxyCodeLine{01186   \}}
\DoxyCodeLine{01187   \textcolor{comment}{// Aggiorno le posizioni dei joint}}
\DoxyCodeLine{01188   skeleton-\/>compute();}
\DoxyCodeLine{01189 \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_jacobian_aa7e8f89f2e5da915147a31590c3364cf}\label{class_jacobian_aa7e8f89f2e5da915147a31590c3364cf}} 
\index{Jacobian@{Jacobian}!ZeroDeltaThetas@{ZeroDeltaThetas}}
\index{ZeroDeltaThetas@{ZeroDeltaThetas}!Jacobian@{Jacobian}}
\doxysubsubsection{\texorpdfstring{ZeroDeltaThetas()}{ZeroDeltaThetas()}}
{\footnotesize\ttfamily void Jacobian\+::\+Zero\+Delta\+Thetas (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{01217 \{ dTheta.SetZero(); \}}

\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
E\+:/opentoonz/toonz/sources/include/toonz/ikjacobian.\+h\item 
E\+:/opentoonz/toonz/sources/toonzlib/ikjacobian.\+cpp\end{DoxyCompactItemize}
