\hypertarget{class_t_sound_track_reader_wav}{}\doxysection{TSound\+Track\+Reader\+Wav Class Reference}
\label{class_t_sound_track_reader_wav}\index{TSoundTrackReaderWav@{TSoundTrackReaderWav}}


{\ttfamily \#include $<$tsio\+\_\+wav.\+h$>$}

Inheritance diagram for TSound\+Track\+Reader\+Wav\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_t_sound_track_reader_wav}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_t_sound_track_reader_wav_a013b09002e75e59fe1a174c8c0c025e1}{TSound\+Track\+Reader\+Wav}} (const \mbox{\hyperlink{class_t_file_path}{TFile\+Path}} \&fp)
\item 
\mbox{\hyperlink{class_t_smart_pointer_t}{TSound\+TrackP}} \mbox{\hyperlink{class_t_sound_track_reader_wav_abcf0b91b5af0ad7ed655ab50a4350665}{load}} () override
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{class_t_sound_track_reader}{TSound\+Track\+Reader}} $\ast$ \mbox{\hyperlink{class_t_sound_track_reader_wav_a4857c90f19c5d1fc5678bf0641c1f134}{create}} (const \mbox{\hyperlink{class_t_file_path}{TFile\+Path}} \&fp)
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
The class \mbox{\hyperlink{class_t_sound_track_reader_wav}{TSound\+Track\+Reader\+Wav}} reads audio files having .wav extension 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_t_sound_track_reader_wav_a013b09002e75e59fe1a174c8c0c025e1}\label{class_t_sound_track_reader_wav_a013b09002e75e59fe1a174c8c0c025e1}} 
\index{TSoundTrackReaderWav@{TSoundTrackReaderWav}!TSoundTrackReaderWav@{TSoundTrackReaderWav}}
\index{TSoundTrackReaderWav@{TSoundTrackReaderWav}!TSoundTrackReaderWav@{TSoundTrackReaderWav}}
\doxysubsubsection{\texorpdfstring{TSoundTrackReaderWav()}{TSoundTrackReaderWav()}}
{\footnotesize\ttfamily TSound\+Track\+Reader\+Wav\+::\+TSound\+Track\+Reader\+Wav (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_t_file_path}{TFile\+Path}} \&}]{fp }\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{00173     : \mbox{\hyperlink{class_t_sound_track_reader}{TSoundTrackReader}}(fp) \{\}}

\end{DoxyCode}
\mbox{\Hypertarget{class_t_sound_track_reader_wav_a53a0f28d072e2c4a797f4e4658e4420e}\label{class_t_sound_track_reader_wav_a53a0f28d072e2c4a797f4e4658e4420e}} 
\index{TSoundTrackReaderWav@{TSoundTrackReaderWav}!````~TSoundTrackReaderWav@{$\sim$TSoundTrackReaderWav}}
\index{````~TSoundTrackReaderWav@{$\sim$TSoundTrackReaderWav}!TSoundTrackReaderWav@{TSoundTrackReaderWav}}
\doxysubsubsection{\texorpdfstring{$\sim$TSoundTrackReaderWav()}{~TSoundTrackReaderWav()}}
{\footnotesize\ttfamily TSound\+Track\+Reader\+Wav\+::$\sim$\+TSound\+Track\+Reader\+Wav (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{00016 \{\}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_t_sound_track_reader_wav_a4857c90f19c5d1fc5678bf0641c1f134}\label{class_t_sound_track_reader_wav_a4857c90f19c5d1fc5678bf0641c1f134}} 
\index{TSoundTrackReaderWav@{TSoundTrackReaderWav}!create@{create}}
\index{create@{create}!TSoundTrackReaderWav@{TSoundTrackReaderWav}}
\doxysubsubsection{\texorpdfstring{create()}{create()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_t_sound_track_reader}{TSound\+Track\+Reader}} $\ast$ TSound\+Track\+Reader\+Wav\+::create (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_t_file_path}{TFile\+Path}} \&}]{fp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns a soundtrack reader able to read .wav audio files 
\begin{DoxyCode}{0}
\DoxyCodeLine{00027                                                         \{}
\DoxyCodeLine{00028     \textcolor{keywordflow}{return} \textcolor{keyword}{new} \mbox{\hyperlink{class_t_sound_track_reader_wav}{TSoundTrackReaderWav}}(fp);}
\DoxyCodeLine{00029   \}}

\end{DoxyCode}
\mbox{\Hypertarget{class_t_sound_track_reader_wav_abcf0b91b5af0ad7ed655ab50a4350665}\label{class_t_sound_track_reader_wav_abcf0b91b5af0ad7ed655ab50a4350665}} 
\index{TSoundTrackReaderWav@{TSoundTrackReaderWav}!load@{load}}
\index{load@{load}!TSoundTrackReaderWav@{TSoundTrackReaderWav}}
\doxysubsubsection{\texorpdfstring{load()}{load()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_t_smart_pointer_t}{TSound\+TrackP}} TSound\+Track\+Reader\+Wav\+::load (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Loads the .wav audio file whose path has been specified in the constructor. It returns a TSound\+TrackP created from the audio file 

Implements \mbox{\hyperlink{class_t_sound_track_reader}{TSound\+Track\+Reader}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00177                                         \{}
\DoxyCodeLine{00178   \textcolor{keywordtype}{char} chunkName[5];}
\DoxyCodeLine{00179   \textcolor{keywordtype}{char} RIFFType[5];}
\DoxyCodeLine{00180   TINT32 chunkLength;}
\DoxyCodeLine{00181 }
\DoxyCodeLine{00182   \mbox{\hyperlink{class_tifstream}{Tifstream}} is(m\_path);}
\DoxyCodeLine{00183 }
\DoxyCodeLine{00184   \textcolor{keywordflow}{if} (!is) \textcolor{keywordflow}{throw} \mbox{\hyperlink{class_t_exception}{TException}}(m\_path.getWideString() + L\textcolor{stringliteral}{"{} : File doesn't exist"{}});}
\DoxyCodeLine{00185 }
\DoxyCodeLine{00186   \textcolor{comment}{// legge il nome del chunk}}
\DoxyCodeLine{00187   is.read((\textcolor{keywordtype}{char} *)\&chunkName, \textcolor{keyword}{sizeof}(chunkName) -\/ 1);}
\DoxyCodeLine{00188   chunkName[4] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00189 }
\DoxyCodeLine{00190   \textcolor{comment}{// legge la lunghezza del chunk}}
\DoxyCodeLine{00191   is.read((\textcolor{keywordtype}{char} *)\&chunkLength, \textcolor{keyword}{sizeof}(chunkLength));}
\DoxyCodeLine{00192 }
\DoxyCodeLine{00193   \textcolor{keywordflow}{if} (!TNZ\_LITTLE\_ENDIAN) chunkLength = swapTINT32(chunkLength);}
\DoxyCodeLine{00194 }
\DoxyCodeLine{00195   \textcolor{comment}{// legge il RIFFType}}
\DoxyCodeLine{00196   is.read((\textcolor{keywordtype}{char} *)\&RIFFType, \textcolor{keyword}{sizeof}(RIFFType) -\/ 1);}
\DoxyCodeLine{00197   RIFFType[4] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00198 }
\DoxyCodeLine{00199   \textcolor{comment}{// per i .wav il RIFFType DEVE essere uguale a "{}WAVE"{}}}
\DoxyCodeLine{00200   \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{string}(RIFFType, 4) != \textcolor{stringliteral}{"{}WAVE"{}}))}
\DoxyCodeLine{00201     \textcolor{keywordflow}{throw} \mbox{\hyperlink{class_t_exception}{TException}}(\textcolor{stringliteral}{"{}The WAV file doesn't contain the WAVE form"{}});}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203   \mbox{\hyperlink{class_t_f_m_t_chunk}{TFMTChunk}} *fmtChunk   = 0;}
\DoxyCodeLine{00204   \mbox{\hyperlink{class_t_d_a_t_a_chunk}{TDATAChunk}} *dataChunk = 0;}
\DoxyCodeLine{00205 }
\DoxyCodeLine{00206   \textcolor{keywordflow}{while} (!is.eof()) \{}
\DoxyCodeLine{00207     \textcolor{keywordtype}{string} name   = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{00208     TINT32 length = 0;}
\DoxyCodeLine{00209 }
\DoxyCodeLine{00210     \textcolor{keywordtype}{bool} ret = TWAVChunk::readHeader(is, name, length);}
\DoxyCodeLine{00211 }
\DoxyCodeLine{00212     \textcolor{keywordflow}{if} (!ret) \textcolor{keywordflow}{break};}
\DoxyCodeLine{00213 }
\DoxyCodeLine{00214     \textcolor{comment}{// legge solo i chunk che ci interessano, ossia FMT e DATA}}
\DoxyCodeLine{00215 }
\DoxyCodeLine{00216     \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"{}fmt "{}}) \{}
\DoxyCodeLine{00217       \textcolor{comment}{// legge i dati del chunk FMT}}
\DoxyCodeLine{00218       fmtChunk = \textcolor{keyword}{new} \mbox{\hyperlink{class_t_f_m_t_chunk}{TFMTChunk}}(length);}
\DoxyCodeLine{00219       fmtChunk-\/>read(is);}
\DoxyCodeLine{00220 }
\DoxyCodeLine{00221       \textcolor{comment}{// considera il byte di pad alla fine del chunk nel caso}}
\DoxyCodeLine{00222       \textcolor{comment}{// in cui la lunghezza di questi e' dispari}}
\DoxyCodeLine{00223       \textcolor{keywordflow}{if} (length \& 1) \{}
\DoxyCodeLine{00224         is.seekg((\textcolor{keywordtype}{long})is.tellg() + 1);}
\DoxyCodeLine{00225       \}}
\DoxyCodeLine{00226     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"{}data"{}}) \{}
\DoxyCodeLine{00227       \textcolor{comment}{// legge i dati del chunk DATA}}
\DoxyCodeLine{00228       dataChunk = \textcolor{keyword}{new} \mbox{\hyperlink{class_t_d_a_t_a_chunk}{TDATAChunk}}(length);}
\DoxyCodeLine{00229 }
\DoxyCodeLine{00230       dataChunk-\/>read(is);}
\DoxyCodeLine{00231 }
\DoxyCodeLine{00232       \textcolor{comment}{// considera il byte di pad alla fine del chunk nel caso}}
\DoxyCodeLine{00233       \textcolor{comment}{// in cui la lunghezza di questi e' dispari}}
\DoxyCodeLine{00234       \textcolor{keywordflow}{if} (length \& 1) \{}
\DoxyCodeLine{00235         is.seekg((\textcolor{keywordtype}{long})is.tellg() + 1);}
\DoxyCodeLine{00236       \}}
\DoxyCodeLine{00237     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00238       \textcolor{comment}{// spostati nello stream di un numero di byte pari a length}}
\DoxyCodeLine{00239       \textcolor{keywordflow}{if} (length \& 1)}
\DoxyCodeLine{00240         is.seekg((\textcolor{keywordtype}{long})is.tellg() + (\textcolor{keywordtype}{long})length + 1);}
\DoxyCodeLine{00241       \textcolor{keywordflow}{else}}
\DoxyCodeLine{00242         is.seekg((\textcolor{keywordtype}{long})is.tellg() + (\textcolor{keywordtype}{long})length);}
\DoxyCodeLine{00243     \}}
\DoxyCodeLine{00244   \}}
\DoxyCodeLine{00245 }
\DoxyCodeLine{00246   \mbox{\hyperlink{class_t_smart_pointer_t}{TSoundTrackP}} track = 0;}
\DoxyCodeLine{00247 }
\DoxyCodeLine{00248   \textcolor{keywordflow}{if} (fmtChunk \&\& dataChunk) \{}
\DoxyCodeLine{00249     TINT32 sampleCount = dataChunk-\/>m\_length / fmtChunk-\/>m\_bytesPerSample;}
\DoxyCodeLine{00250     \textcolor{keywordtype}{bool} signedSample  = (fmtChunk-\/>m\_bitPerSample != 8);}
\DoxyCodeLine{00251 }
\DoxyCodeLine{00252     track = \mbox{\hyperlink{class_t_sound_track_a9a83177a9a5b9a7470f32b87e7f21f3d}{TSoundTrack::create}}((\textcolor{keywordtype}{int})fmtChunk-\/>m\_sampleRate,}
\DoxyCodeLine{00253                                 fmtChunk-\/>m\_bitPerSample, fmtChunk-\/>m\_chans,}
\DoxyCodeLine{00254                                 sampleCount, signedSample);}
\DoxyCodeLine{00255 }
\DoxyCodeLine{00256     \textcolor{keywordflow}{if} (track) \{}
\DoxyCodeLine{00257       \textcolor{keywordflow}{switch} (fmtChunk-\/>m\_bitPerSample) \{}
\DoxyCodeLine{00258       \textcolor{keywordflow}{case} 8:}
\DoxyCodeLine{00259         memcpy((\textcolor{keywordtype}{void} *)track-\/>\mbox{\hyperlink{class_t_sound_track_ae47a8e255a18ddbc83d31b6c0c834e68}{getRawData}}(),}
\DoxyCodeLine{00260                (\textcolor{keywordtype}{void} *)(dataChunk-\/>m\_samples.get()),}
\DoxyCodeLine{00261                sampleCount * fmtChunk-\/>m\_bytesPerSample);}
\DoxyCodeLine{00262         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00263       \textcolor{keywordflow}{case} 16:}
\DoxyCodeLine{00264         \textcolor{keywordflow}{if} (!TNZ\_LITTLE\_ENDIAN)}
\DoxyCodeLine{00265           swapAndCopySamples((\textcolor{keywordtype}{short} *)dataChunk-\/>m\_samples.get(),}
\DoxyCodeLine{00266                              (\textcolor{keywordtype}{short} *)track-\/>\mbox{\hyperlink{class_t_sound_track_ae47a8e255a18ddbc83d31b6c0c834e68}{getRawData}}(),}
\DoxyCodeLine{00267                              sampleCount * fmtChunk-\/>m\_chans);}
\DoxyCodeLine{00268         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00269           memcpy((\textcolor{keywordtype}{void} *)track-\/>\mbox{\hyperlink{class_t_sound_track_ae47a8e255a18ddbc83d31b6c0c834e68}{getRawData}}(),}
\DoxyCodeLine{00270                  (\textcolor{keywordtype}{void} *)(dataChunk-\/>m\_samples.get()),}
\DoxyCodeLine{00271                  sampleCount * fmtChunk-\/>m\_bytesPerSample);}
\DoxyCodeLine{00272         \textcolor{comment}{//\#endif}}
\DoxyCodeLine{00273         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00274       \textcolor{keywordflow}{case} 24:}
\DoxyCodeLine{00275         \textcolor{keywordflow}{if} (!TNZ\_LITTLE\_ENDIAN) \{}
\DoxyCodeLine{00276           UCHAR *begin = (UCHAR *)track-\/>\mbox{\hyperlink{class_t_sound_track_ae47a8e255a18ddbc83d31b6c0c834e68}{getRawData}}();}
\DoxyCodeLine{00277           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < (int)(sampleCount * fmtChunk-\/>m\_chans); ++i) \{}
\DoxyCodeLine{00278             *(begin + 4 * i)     = 0;}
\DoxyCodeLine{00279             *(begin + 4 * i + 1) = *(dataChunk-\/>m\_samples.get() + 3 * i + 2);}
\DoxyCodeLine{00280             *(begin + 4 * i + 2) = *(dataChunk-\/>m\_samples.get() + 3 * i + 1);}
\DoxyCodeLine{00281             *(begin + 4 * i + 3) = *(dataChunk-\/>m\_samples.get() + 3 * i);}
\DoxyCodeLine{00282           \}}
\DoxyCodeLine{00283         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00284           UCHAR *begin = (UCHAR *)track-\/>\mbox{\hyperlink{class_t_sound_track_ae47a8e255a18ddbc83d31b6c0c834e68}{getRawData}}();}
\DoxyCodeLine{00285           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < (int)(sampleCount * fmtChunk-\/>m\_chans); ++i) \{}
\DoxyCodeLine{00286             memcpy((\textcolor{keywordtype}{void} *)(begin + 4 * i),}
\DoxyCodeLine{00287                    (\textcolor{keywordtype}{void} *)(dataChunk-\/>m\_samples.get() + 3 * i), 3);}
\DoxyCodeLine{00288             *(begin + 4 * i + 3) = 0;}
\DoxyCodeLine{00289           \}}
\DoxyCodeLine{00290         \}}
\DoxyCodeLine{00291         \textcolor{comment}{//\#endif}}
\DoxyCodeLine{00292         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00293       \}}
\DoxyCodeLine{00294     \}}
\DoxyCodeLine{00295 }
\DoxyCodeLine{00296     \textcolor{comment}{/*if (!TNZ\_LITTLE\_ENDIAN)}}
\DoxyCodeLine{00297 \textcolor{comment}{\{}}
\DoxyCodeLine{00298 \textcolor{comment}{if (fmtChunk-\/>m\_bitPerSample > 8)}}
\DoxyCodeLine{00299 \textcolor{comment}{\{}}
\DoxyCodeLine{00300 \textcolor{comment}{assert(fmtChunk-\/>m\_bitPerSample <= 16);}}
\DoxyCodeLine{00301 \textcolor{comment}{swapAndCopySamples(}}
\DoxyCodeLine{00302 \textcolor{comment}{(short*)dataChunk-\/>m\_samples,}}
\DoxyCodeLine{00303 \textcolor{comment}{(short*)track-\/>getRawData(),}}
\DoxyCodeLine{00304 \textcolor{comment}{sampleCount*fmtChunk-\/>m\_chans);}}
\DoxyCodeLine{00305 \textcolor{comment}{\}}}
\DoxyCodeLine{00306 \textcolor{comment}{else}}
\DoxyCodeLine{00307 \textcolor{comment}{memcpy(}}
\DoxyCodeLine{00308 \textcolor{comment}{    (void*)track-\/>getRawData(),}}
\DoxyCodeLine{00309 \textcolor{comment}{(void*)(dataChunk-\/>m\_samples),}}
\DoxyCodeLine{00310 \textcolor{comment}{sampleCount*fmtChunk-\/>m\_bytesPerSample);}}
\DoxyCodeLine{00311 \textcolor{comment}{\}}}
\DoxyCodeLine{00312 \textcolor{comment}{else}}
\DoxyCodeLine{00313 \textcolor{comment}{memcpy(}}
\DoxyCodeLine{00314 \textcolor{comment}{(void*)track-\/>getRawData(),}}
\DoxyCodeLine{00315 \textcolor{comment}{(void*)(dataChunk-\/>m\_samples),}}
\DoxyCodeLine{00316 \textcolor{comment}{sampleCount*fmtChunk-\/>m\_bytesPerSample);*/}}
\DoxyCodeLine{00317   \}}
\DoxyCodeLine{00318 }
\DoxyCodeLine{00319   \textcolor{keywordflow}{if} (fmtChunk) \textcolor{keyword}{delete} fmtChunk;}
\DoxyCodeLine{00320   \textcolor{keywordflow}{if} (dataChunk) \textcolor{keyword}{delete} dataChunk;}
\DoxyCodeLine{00321 }
\DoxyCodeLine{00322   \textcolor{keywordflow}{return} track;}
\DoxyCodeLine{00323 \}}

\end{DoxyCode}


References \mbox{\hyperlink{l00078}{TSound\+Track\+::create()}}, and \mbox{\hyperlink{l00150}{TSound\+Track\+::get\+Raw\+Data()}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
E\+:/opentoonz/toonz/sources/sound/wav/tsio\+\_\+wav.\+h\item 
E\+:/opentoonz/toonz/sources/sound/wav/tsio\+\_\+wav.\+cpp\end{DoxyCompactItemize}
